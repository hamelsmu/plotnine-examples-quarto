[
  {
    "objectID": "facet_grid.html",
    "href": "facet_grid.html",
    "title": "Facet grid",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    labs,\n    facet_grid,\n    theme,\n    element_text\n)\nfrom plotnine.data import mpg\n\nfacet_grid() is used to form a grid of plots, where the rows and columns of the grid are set by the faceting variables. It is useful for visualising two discrete variables.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFacet a discrete variable into rows:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv ~ .')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFacet a discrete variable into columns:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('. ~ cyl')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFacet two discrete variables into rows and columns:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv ~ cyl')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nTo change the plot order of the rows or columns in the facet grid, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg['drv'] = mpg['drv'].cat.reorder_categories(['f', 'r','4'])\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv ~ cyl')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable by using the scales argument within the facet_grid() command:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv ~ .', scales = 'free')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_grid() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv ~ .', labeller = 'label_both')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg['trans'].map(lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\")\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_grid('drv + transmission ~ .') # use + to add additional faceting variables\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFacet labels can be rotated to make them easier to read using strip_text_y = element_text(angle = 0) for row labels within the theme() command (use strip_text_x = element_text(angle = 0) for column labels).\nIf the labels do not fit in the strip, adjust the width of the strip using strip_background_y for rows (use strip_background_x for columns). You may also need to adjust the text position so it fits in the strip: adjust the horizontal text position in the strip by specifying ha in element_text()(specify va in element_text() to adjust the vertical text position).\nYou can also change the colour of the strip by specifying color in element_text() .\n\n(\n    ggplot(mpg, aes(x='drv', y='model'))\n    + geom_point()\n    + facet_grid('manufacturer ~ .', scales = 'free')\n    + theme(strip_text_y = element_text(angle = 0,              # change facet text angle\n                                        ha = 'left'             # change text alignment\n                                       ),\n            strip_background_y = element_text(color = '#969dff' # change background colour of facet background\n                                              , width = 0.2     # adjust width of facet background to fit facet text\n                                             ),\n            figure_size=(6, 15)                                 # adjust width & height of figure to fit y-axis\n           )\n    + labs(x='displacement', y='')\n)\n\n\n\n\n&lt;Figure Size: (600 x 1500)&gt;"
  },
  {
    "objectID": "geom_smooth.html",
    "href": "geom_smooth.html",
    "title": "Smoothed conditional means",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_smooth,\n    labs\n)\nfrom plotnine.data import mpg\n\nAids the eye in seeing patterns in the presence of overplotting.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_smooth()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nUse span to control the “wiggliness” of the default loess smoother. The span is the fraction of points used to fit each local regression: small numbers make a wigglier curve, larger numbers make a smoother curve.\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_smooth(span=.3)\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can remove confidence interval around smooth with se=False:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_smooth(span=.3, se=False)\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nInstead of a loess smooth, you can use any other modelling function:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_smooth(method='lm')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n# Gallery Plot\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy', color='factor(drv)')) \n    + geom_point()\n    + geom_smooth(method='lm')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_hline.html",
    "href": "geom_hline.html",
    "title": "Horizontal line",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_hline,\n    facet_grid,\n    labs\n)\nfrom plotnine.data import mpg\n\ngeom_hline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_hline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nNow add a horizontal line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_hline(yintercept = 25) # add one horizonal line\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add many horizontal lines:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_hline(yintercept = [25,35,45]) # add many horizontal lines using a list\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_hline(yintercept = 25,\n                  color='yellow',    # set line colour\n                  size=2,            # set line thickness\n                  linetype=\"dashed\"  # set line type\n                 )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAnd you can add horizontal lines to a facet plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_hline(yintercept = 25) # add a vertical line...\n    + facet_grid('drv ~ .')      # ... to a facet plot\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_violin.html",
    "href": "geom_violin.html",
    "title": "Violins, Boxes, Points and Lines",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport pandas.api.types as pdtypes\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    stage,\n    geom_violin,\n    geom_point,\n    geom_line,\n    geom_boxplot,\n    scale_fill_manual,\n    theme,\n    theme_classic\n)\n\nComparing repeated measurements and their summaries\nSuppose you have two sets of related data and each point in the first set maps onto a point in the second set. e.g. they could represent a transition from one state to another for example two measurements of the height of pupils in different years.\nFor demonstration we shall generate data with a before measurement and an after measurement.\n\nnp.random.seed(123)\nn = 20\nmu = (1, 2.3)\nsigma = (1, 1.6)\n\nbefore = np.random.normal(loc=mu[0], scale=sigma[0], size=n)\nafter = np.random.normal(loc=mu[1], scale=sigma[1], size=n)\n\ndf = pd.DataFrame({\n    'value': np.hstack([before, after]),\n    'when': np.repeat(['before', 'after'], n),\n    'id': np.hstack([range(n), range(n)])\n})\n\ndf['when'] = df['when'].astype(pdtypes.CategoricalDtype(categories=['before', 'after']))\ndf.head()\n\n\n\n\n\n\n\n\nvalue\nwhen\nid\n\n\n\n\n0\n-0.085631\nbefore\n0\n\n\n1\n1.997345\nbefore\n1\n\n\n2\n1.282978\nbefore\n2\n\n\n3\n-0.506295\nbefore\n3\n\n\n4\n0.421400\nbefore\n4\n\n\n\n\n\n\n\nA basic violin plot shows distributions of the two sets of data.\n\n(ggplot(df, aes('when', 'value'))\n + geom_violin(df)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAdd the original data in form of points.\n\n(ggplot(df, aes('when', 'value'))\n + geom_violin(df)\n + geom_point()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe violins are symmetrical about the vertical axis and half a violin has the same information as the full violin. We cut (style) the violins in half and choose to alternate with the left half for the first one and the right half for the second.\n\n(ggplot(df, aes('when', 'value'))\n + geom_violin(df, style='left-right') # changed\n + geom_point()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nLink up the points to get a sense of how the data the moves.\n\n(ggplot(df, aes('when', 'value'))\n + geom_violin(df, style='left-right') # changed\n + geom_point()\n + geom_line(aes(group='id'))          # new\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nMake gap between the points and the violions. i.e. shift the violins outward and the points & lines inward. We used stage mapping to get it done. For example\nx=stage('when', after_scale='x+shift*alt_sign(x)')\nsays, map the xaesthetic to the ‘when’ column/variable and after the scale computed the x locations add a shift to them. The calculated x locations of a discrete scale are consecutive numbers 1, 2, 3, ..., so we use that move objects of adjacent groups in opposite directions i.e $(-1)^1, (-1)^2, (-1)^3 … = -1, 1, -1… $\n\n# How much to shift the violin, points and lines\n# 0.1 is 10% of the allocated space for the category\nshift = 0.1\n\ndef alt_sign(x):\n    \"Alternate +1/-1 if x is even/odd\"\n    return (-1) ** x\n\nm1 = aes(x=stage('when', after_scale='x+shift*alt_sign(x)'))              # shift outward\nm2 = aes(x=stage('when', after_scale='x-shift*alt_sign(x)'), group='id')  # shift inward\n         \n(ggplot(df, aes('when', 'value'))\n + geom_violin(m1, style='left-right') # changed\n + geom_point(m2)                      # changed\n + geom_line(m2)                       # changed\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAdd a boxplot in the gap. The space between the flat edge of the violin and the center of the points is 2 * shift, so we can use the shift to control the width of the boxplot.\n\n(ggplot(df, aes('when', 'value'))\n + geom_violin(m1, style='left-right')\n + geom_point(m2)\n + geom_line(m2)\n + geom_boxplot(width=shift)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFinall, style it up.\n\n# Gallery Plot\nlsize = 0.65\nfill_alpha = 0.7\n\n(ggplot(df, aes('when', 'value', fill='when'))\n + geom_violin(m1, style='left-right', alpha=fill_alpha, size=lsize, show_legend=False)\n + geom_point(m2, color='none', alpha=fill_alpha, size=2, show_legend=False)\n + geom_line(m2, color='gray', size=lsize, alpha=0.6)\n + geom_boxplot(width=shift, alpha=fill_alpha, size=lsize, show_legend=False)\n + scale_fill_manual(values=['dodgerblue', 'darkorange'])\n + theme_classic()\n + theme(figure_size=(8, 6))\n)\n\n\n\n\n&lt;Figure Size: (800 x 600)&gt;\n\n\nCredit: This is example is motivated by the work of Jordy van Langen (@jorvlan) at https://github.com/jorvlan/open-visualizations."
  },
  {
    "objectID": "theme.html",
    "href": "theme.html",
    "title": "Theming specific items",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    facet_grid,\n    labs,\n    guide_legend,\n    guides,\n    theme,\n    element_text,\n    element_line,\n    element_rect,\n    theme_set,\n    theme_void\n)\nfrom plotnine.data import mtcars\n\n# We use theme_void as the base theme so that the modifications\n# we make in the code are transparent in the output\ntheme_set(theme_void())\n\n\nmtcars.head()\n\n\n\n\n\n\n\n\nname\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\nThe base plots we will use for the demonstation and some colors.\n\np1 = (ggplot(mtcars, aes('wt', 'mpg', color='factor(cyl)'))\n      + geom_point()\n      + labs(title='mpg vs wt')\n     )\n\np2 = p1 + facet_grid('gear ~ am')\n\nblack = '#222222'\ngray = '#666666'\nred = '#FF3333'\ngreen = '#66CC00'\nblue = '#3333FF'\npurple = '#9933FF'\norange = '#FF8000'\nyellow = '#FFFF33'\n\nWhat the plots look like unmodified (unthemed).\n\np1\n\n\n\n\n\np2\n\n\n\n\nThere are 3 main top level theming elements:\n\ntext - controls all the text elements in the figure.\nrect - controls all the rectangles in the figure.\nline - controls all the lines in the figure.\n\nNote that none of the themeables control/modify the plotted data. e.g You cannot use text to change the appearance of objects plotted with geom_text.\ntext\n\np1 + theme(\n    text=element_text(color=purple)\n)\n\n\n\n\nrect\n\np1 + theme(\n    rect=element_rect(color=black, size=3, fill='#EEBB0050')\n) \n\n\n\n\nline\n\np1 + theme(\n    line=element_line(color=black)\n)\n\n\n\n\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    \n    axis_text=element_text(margin={'t': 5, 'r': 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple)\n)\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=.7, color=gray),\n    \n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    \n    axis_ticks=element_line(size=2),\n    \n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),        # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    \n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),              # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),    # override color=red\n\n)\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=.7, color=gray),\n    axis_ticks=element_line(),\n    \n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    \n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20\n)\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=.7, color=gray),\n    axis_ticks=element_line(),\n    \n    axis_ticks_direction='in',\n    axis_ticks_direction_x='in',\n    axis_ticks_direction_y='out'\n)\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(p1 + aes(fill='drat')\n + theme(\n    legend_position='left',\n    legend_direction='horizontal', # affected by the ncol=2\n    legend_title_align='center',\n    legend_box_margin=5,\n    legend_background=element_rect(color=purple, size=2, fill='white'),\n     \n    legend_box='vertical',\n     \n    legend_key=element_rect(fill=gray, alpha=.3),\n    legend_title=element_text(color=orange),\n    legend_text=element_text(weight='bold'),\n    \n    legend_key_size=30,            # overridden\n    legend_key_width=30,\n    legend_key_height=15,\n\n    legend_entry_spacing=10,      # overridden\n    legend_entry_spacing_x=15,\n    legend_entry_spacing_y=5) \n \n # so we can see legend_entry_spacing in action\n + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill='gray', alpha=.3),\n    panel_background=element_rect(fill=purple, alpha=.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=.25,\n    #panel_spacing_x=.05,\n    #panel_spacing_y=.25\n)\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    \n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype='dashed'),\n    panel_grid_major_y=element_line(linetype='dashdot'),\n    \n    panel_grid_minor=element_line(alpha=.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    \n    panel_ontop=False  # puts the points behind the grid\n )\n\n\n\n\n\n\nstrip_background, strip_margin and strip_text\n\np2 + theme(\n    panel_spacing=.25,\n    \n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=.95),\n    strip_background_x=element_rect(x=1/6, width=2/3), # you can get really crazy\n    strip_background_y=element_rect(),\n    \n    strip_margin=0,\n    strip_margin_x=0.2,\n    strip_margin_y=0.2,\n    \n    strip_text=element_text(weight='bold'),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue)\n )\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=.2),\n    #dpi=120,\n    figure_size=(8, 6), # inches\n    aspect_ratio=1/3    # height:width\n)"
  },
  {
    "objectID": "geom_col.html",
    "href": "geom_col.html",
    "title": "Two Variable Bar Plot",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_col,\n    geom_text,\n    position_dodge,\n    lims,\n    theme,\n    element_text,\n    element_blank,\n    element_rect,\n    element_line,\n)\n\nVisualising on a single plot the values of a variable that has nested (and independent) variables\nCreate the data\n\ndf = pd.DataFrame({\n    'variable': ['gender', 'gender', 'age', 'age', 'age', 'income', 'income', 'income', 'income'],\n    'category': ['Female', 'Male', '1-24', '25-54', '55+', 'Lo', 'Lo-Med', 'Med', 'High'],\n    'value': [60, 40, 50, 30, 20, 10, 25, 25, 40],\n})\ndf['variable'] = pd.Categorical(df['variable'], categories=['gender', 'age', 'income'])\ndf['category'] = pd.Categorical(df['category'], categories=df['category'])\n\ndf\n\n\n\n\n\n\n\n\nvariable\ncategory\nvalue\n\n\n\n\n0\ngender\nFemale\n60\n\n\n1\ngender\nMale\n40\n\n\n2\nage\n1-24\n50\n\n\n3\nage\n25-54\n30\n\n\n4\nage\n55+\n20\n\n\n5\nincome\nLo\n10\n\n\n6\nincome\nLo-Med\n25\n\n\n7\nincome\nMed\n25\n\n\n8\nincome\nHigh\n40\n\n\n\n\n\n\n\nWe want to visualise this data and at a galance get an idea to how the value breaks down along the categorys for the different variable. Note that each variable has different categorys.\nFirst we make a simple plot with all this information and see what to draw from it.\n\n(ggplot(df, aes(x='variable', y='value', fill='category'))\n + geom_col()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAll the values along each variable add up to 100, but stacked together the difference within and without the groups is not clear. The solution is to dodge the bars.\n\n(ggplot(df, aes(x='variable', y='value', fill='category'))\n + geom_col(stat='identity', position='dodge'))                     # modified\n\n\n\n\nTwo variable bar plot\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThis is good, it gives us the plot we want but the legend is not great. Each variable has a different set of categorys, but the legend has them all clamped together. We cannot easily change the legend, but we can replicate it’s purpose by labelling the individual bars.\nTo do this, we create a geom_text with position_dodge(width=0.9) to match the ratio of the space taken up by each variable. If there was no spacing between the bars of different variables, we would have width=1.\nA minor quack, when text extends beyond the limits we have to manually make space or it would get clipped. Therefore we adjust the bottom y limits.\n\ndodge_text = position_dodge(width=0.9)                              # new\n\n(ggplot(df, aes(x='variable', y='value', fill='category'))\n + geom_col(stat='identity', position='dodge', show_legend=False)   # modified\n + geom_text(aes(y=-.5, label='category'),                          # new\n             position=dodge_text,\n             color='gray', size=8, angle=45, va='top')\n + lims(y=(-5, 60))                                                 # new\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWould it look too crowded if we add value labels on top of the bars?\n\ndodge_text = position_dodge(width=0.9)\n\n(ggplot(df, aes(x='variable', y='value', fill='category'))\n + geom_col(stat='identity', position='dodge', show_legend=False)\n + geom_text(aes(y=-.5, label='category'),\n             position=dodge_text,\n             color='gray', size=8, angle=45, va='top')\n + geom_text(aes(label='value'),                                    # new\n             position=dodge_text,\n             size=8, va='bottom', format_string='{}%')\n + lims(y=(-5, 60))\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThat looks okay. The values line up with the categorys because we used the same dodge parameters. For the final polish, we remove the y-axis, clear out the panel and make the variable and category labels have the same color.\n\ndodge_text = position_dodge(width=0.9)\nccolor = '#555555'\n\n# Gallery Plot\n\n(ggplot(df, aes(x='variable', y='value', fill='category'))\n + geom_col(stat='identity', position='dodge', show_legend=False)\n + geom_text(aes(y=-.5, label='category'),\n             position=dodge_text,\n             color=ccolor, size=8, angle=45, va='top')              # modified\n + geom_text(aes(label='value'),\n             position=dodge_text,\n             size=8, va='bottom', format_string='{}%')\n + lims(y=(-5, 60))\n + theme(panel_background=element_rect(fill='white'),               # new\n         axis_title_y=element_blank(),\n         axis_line_x=element_line(color='black'),\n         axis_line_y=element_blank(),\n         axis_text_y=element_blank(),\n         axis_text_x=element_text(color=ccolor),\n         axis_ticks_major_y=element_blank(),\n         panel_grid=element_blank(),\n         panel_border=element_blank())\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nCredit: I saved a plot this example is based on a while ago and forgot/misplaced the link to the source. The user considered it a minor coup."
  },
  {
    "objectID": "after_stat.html",
    "href": "after_stat.html",
    "title": "after_stat",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_bar,\n    labs\n)\n\ngeom_bar uses stat_count which by default maps the y aesthetic to the count which is the number of observations at a position.\n\ndf = pd.DataFrame({\n    'var1': [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n})\n\n(ggplot(df, aes('var1'))\n + geom_bar()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nUsing the after_stat function, we can instead map to the prop which is the ratio of points in the panel at a position.\n\n(ggplot(df, aes('var1'))\n + geom_bar(aes(y=after_stat('prop'))) # default is after_stat('count')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWith after_stat you can used the variables calculated by the stat in expressions. For example we use the count to calculated the prop.\n\n(ggplot(df, aes('var1'))\n + geom_bar(aes(y=after_stat('count / np.sum(count)')))\n + labs(y='prop')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nBy default geom_bar uses stat_count to compute a frequency table with the x aesthetic as the key column. As a result, any mapping (other than the x aesthetic is lost) to a continuous variable is lost (if you have a classroom and you compute a frequency table of the gender, you lose any other information like height of students).\nFor example, below fill='var1' has no effect, but the var1 variable has not been lost it has been turned into x aesthetic.\n\n(ggplot(df, aes('var1'))\n + geom_bar(aes(fill='var1'))\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWe use after_stat to map fill to the x aesthetic after it has been computed.\n\n(ggplot(df, aes('var1'))\n + geom_bar(aes(fill=after_stat('x')))\n + labs(fill='var1')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "facet_wrap.html",
    "href": "facet_wrap.html",
    "title": "Facet wrap",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    labs,\n    facet_wrap,\n    theme,\n    element_text\n)\nfrom plotnine.data import mpg\n\nfacet_wrap() creates a collection of plots (facets), where each plot is differentiated by the faceting variable. These plots are wrapped into a certain number of columns or rows as specified by the user.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nFacet a discrete variable using facet_wrap():\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nControl the number of rows and columns with the options nrow and ncol:\n\n# Selecting the number of columns to display\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class',\n                 ncol = 4 # change the number of columns\n                )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n# Selecting the number of rows to display\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class', \n                 nrow = 4 # change the number of columns\n                )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nTo change the plot order of the facets, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg['class'] = mpg['class'].cat.reorder_categories(['pickup', 'suv','minivan','midsize','compact','subcompact','2seater'])\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nOrdinarily the facets are arranged horizontally (left-to-right from top to bottom). However if you would prefer a vertical layout (facets are arranged top-to-bottom, from left to right) use the dir option:\n\n# Facet plot with vertical layout\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class',\n                 dir = 'v' # change to a vertical layout\n                )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable. Set the scales argument to free-y, free_x or free for a free scales on the y-axis, x-axis or both axes respectively. You may need to add spacing between the facets to ensure axis ticks and values are easy to read.\nA fixed scale is the default and does not need to be specified.\n\n# facet plot with free scales\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class'\n                , scales = 'free_y'           # set scales so y-scale varies with the data\n                )\n    + theme(subplots_adjust={'wspace': 0.25}) # add spaceing between facets to make y-axis ticks visible\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_wrap() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n# facet plot with labeller\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap('class', labeller='label_both')\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg['trans'].map(lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\")\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + facet_wrap(['class', 'transmission']) # use ~ + to add additional faceting variables\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_boxplot.html",
    "href": "geom_boxplot.html",
    "title": "A box and whiskers plot",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot,\n    geom_jitter,\n    scale_x_discrete,\n    coord_flip\n)\n\nThe boxplot compactly displays the distribution of a continuous variable.\nRead more: + wikipedia + ggplot2 docs\n\nflights = pd.read_csv('data/flights.csv')\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\nBasic boxplot\n\nmonths = [month[:3] for month in flights.month[:12]]\nprint(months)\n\n['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n\n\n(\n    ggplot(flights) \n    + geom_boxplot(aes(x='factor(month)', y='passengers'))\n    + scale_x_discrete(labels=months, name='month')  # change ticks labels on OX\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nHorizontal boxplot\n\n(\n    ggplot(flights) \n    + geom_boxplot(aes(x='factor(month)', y='passengers'))\n    + coord_flip()\n    + scale_x_discrete(\n        labels=months[::-1], \n        limits=flights.month[12::-1],\n        name='month',\n    )\n)\n\nValueError: The number of FixedLocator locations (13), usually from a call to set_ticks, does not match the number of labels (12).\n\n\nBoxplot with jittered points:\n\n(\n    ggplot(flights, aes(x='factor(month)', y='passengers')) \n    + geom_boxplot()\n    + geom_jitter()\n    + scale_x_discrete(labels=months, name='month')  # change ticks labels on OX\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_vline.html",
    "href": "geom_vline.html",
    "title": "Vertical line",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_vline,\n    facet_grid,\n    labs,\n)\nfrom plotnine.data import mpg\n\ngeom_vline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_vline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAdd a vertical line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_vline(xintercept=5) # add one vertical line\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can add many vertical lines:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_vline(xintercept=[4,5,7]) # add many vertical lines using a list\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_vline(xintercept=[4,5,7],\n                 colour=['red','orange','green'],     # add colour\n                 size=[1,2,3],                          # set line thickness\n                 linetype='dotted'                      # set line type\n                ) \n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAdd vertical lines to a facet plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_vline(xintercept=5) # add a vertical line...\n    + facet_grid('drv ~ .')      # ... to a facet plot\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_count.html",
    "href": "geom_count.html",
    "title": "Categorized Data Plot",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_count,\n    scale_size_continuous\n)\nfrom plotnine.data import diamonds\n\ngeom_count() makes the point size proportional to the number of points at a location\n\ndiamonds.head()\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nggplot(diamonds) + geom_count(aes(x='cut', y='color'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWe can adjust the size range of the points with scale_size_continuous\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x='cut', y='color'))\n    + scale_size_continuous(range=[1,20])\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "after_scale.html",
    "href": "after_scale.html",
    "title": "after_scale",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_scale,\n    geom_bar,\n    theme_classic\n)\n\nThe bars in geom_bar have two aesthetics that control the coloring; fill for the interior and color for the boundary/edge. Using after_scale we can create a matching combination of these two.\nStart off with a mapping to the color.\n\ndf = pd.DataFrame({\n    'var1': [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n})\n\n(ggplot(df, aes('var1', color='factor(var1)'))\n + geom_bar(size=1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWe can match the color with the fill.\n\n(ggplot(df, aes('var1', color='factor(var1)'))\n + geom_bar(aes(fill=after_scale('color')), size=1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAs after_scale takes an expression, for the fill aesthetic we can modify the color by adding to it an alpha channel i.e. '#AABBCC' to '#AABBCC66'.\n\n(ggplot(df, aes('var1', color='factor(var1)'))\n + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWe rely on the fact that you can append a string to all elements of a pandas series\npd.Series(['#AABBCC', '#112233']) + '66' == pd.Series(['#AABBCC66', '#11223366'])\nWith a fitting theme.\n\n(ggplot(df, aes('var1', color='factor(var1)'))\n + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n + theme_classic()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "stage.html",
    "href": "stage.html",
    "title": "stage",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n%aimport plotnine\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_bin_2d,\n    stat_bin_2d,\n)\ndf = pd.DataFrame({\n    'var1': list('abbcccddddeeeee'),\n    'cat': list('RSRSRSRRRSRSSRS')\n})\n\n(ggplot(df, aes('var1'))\n + geom_bar()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\nAdd the corresponding count on top of each bar.\n(ggplot(df, aes('var1'))\n + geom_bar()\n + geom_text(aes(label=after_stat('count')), stat='count')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\nAdjust the y position so that the counts do not overlap the bars.\n(ggplot(df, aes('var1'))\n + geom_bar()\n + geom_text(aes(label=after_stat('count'), y=stage(after_stat='count', after_scale='y+.1')), stat='count')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\nNote that this will work even nicely for stacked bars where adjustig the position with nudge_y=0.1 would not.\n(ggplot(df, aes('var1', fill='cat'))\n + geom_bar()\n + geom_text(aes(label=after_stat('count'), y=stage(after_stat='count', after_scale='y+.1')), stat='count', position='stack')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "stage.html#create-a-binned-2d-plot-with-counts",
    "href": "stage.html#create-a-binned-2d-plot-with-counts",
    "title": "stage",
    "section": "Create a binned 2d plot with counts",
    "text": "Create a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    'col_1': np.random.rand(1000),\n    'col_2': np.random.rand(1000)\n})\n\n\n(ggplot(df, aes(x='col_1', y='col_2'))\n + geom_bin_2d(position='identity', binwidth=0.1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(ggplot(df, aes(x='col_1', y='col_2'))\n + geom_bin_2d(position='identity', binwidth=0.1)\n + stat_bin_2d(\n     aes(\n         x=stage(start='col_1', after_stat='(xmin+xmax)/2'),\n         y=stage(start='col_2', after_stat='(ymin+ymax)/2'),\n         label=after_stat('count')\n     ),\n     binwidth=0.1,\n     geom='text',\n     format_string='{:.0f}',\n     size=10\n )\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_bar.html",
    "href": "geom_bar.html",
    "title": "Bar chart",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_bar,\n    coord_flip,\n    theme_classic\n)\nfrom plotnine.data import mpg\n\ngeom_bar() makes the height of the bar proportional to the number of cases in each group\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\nggplot(mpg) + geom_bar(aes(x='class'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\nggplot(mpg) + geom_bar(aes(x='class', fill='drv'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n(\n    ggplot(mpg) \n    + geom_bar(aes(x='class', fill='drv'))\n    + coord_flip()\n    + theme_classic()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Plotnine Gallery",
    "section": "",
    "text": "Spiral Animation\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nSource: PlotnineAnimation.ipynb\n\n\n\n\n\n\n\n\nTwo variable bar plot\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nSource: geom_col.ipynb\n\n\n\n\n\n\n\n\nShading a region under a density curve\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nSource: geom_density.ipynb\n\n\n\n\n\n\n\n\nThe political territories of Westeros\n\n\n\n\n&lt;Figure Size: (800 x 1200)&gt;\n\n\nSource: geom_map.ipynb\n\n\n\n\n\n\n\n\nRanges of similar variables\n\n\n\n\nSource: geom_segment.ipynb\n\n\n\n\n\n\n\n\nChange in Rank\n\n\n\n\nSource: geom_segment.ipynb"
  },
  {
    "objectID": "geom_point.html",
    "href": "geom_point.html",
    "title": "Plotnine Examples",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    scale_color_gradient\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot\n\np = ggplot(aes(x='displ', y='cty'), mpg)\np + geom_point()\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAesthetic mappings\n\np + geom_point(aes(color='factor(cyl)'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\np + geom_point(aes(shape='factor(cyl)'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\np + geom_point(aes(color='hwy'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nModify the color scale\n\np + geom_point(aes(color='hwy')) + scale_color_gradient(low='blue', high='red')\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\np + geom_point(aes(size='hwy'))\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "geom_histogram.html",
    "href": "geom_histogram.html",
    "title": "Histograms",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_histogram,\n    facet_wrap,\n    facet_grid,\n    coord_flip,\n    scale_y_continuous,\n    scale_y_sqrt,\n    scale_y_log10,\n    scale_fill_manual,\n    theme_bw,\n    theme_xkcd\n    \n)\nfrom plotnine.data import diamonds\nfrom mizani.formatters import percent_format \n\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n(\n    ggplot(diamonds, aes(x='carat')) \n    + geom_histogram()\n)\n\n/Users/hassan/scm/python/plotnine/plotnine/stats/stat_bin.py:109: PlotnineWarning: 'stat_bin()' using 'bins = 142'. Pick better value with 'binwidth'.\n\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x='carat')) \n    + geom_histogram(binwidth=0.5) # specify the binwidth\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x='carat')) \n    + geom_histogram(bins=10) # specify the number of bins\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(diamonds, aes(x='carat',\n                         y=after_stat('count') # specify each bin is a count\n                        )) \n    + geom_histogram(binwidth=0.50)  \n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(diamonds, aes(x='carat',\n                         y=after_stat('ncount') # normalise the count to 1\n                        )) \n    + geom_histogram(binwidth=0.50)  \n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(diamonds, aes(x='carat',\n                         y=after_stat('density') # density\n                        )) \n    + geom_histogram(binwidth=0.50)  \n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(diamonds, aes(x='carat',\n                         y=after_stat('width*density')) # show proportion\n          ) \n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('width*density'))) \n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format()) # display labels as a percentage\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x='carat'))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill='green')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('density'))) \n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('count'),fill='cut')) \n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('count'))) \n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt() # square root scale\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n(\n    ggplot(diamonds, aes(x = 'carat', y = after_stat('count'))) \n    + geom_histogram(binwidth = 0.5)\n    + scale_y_log10() # log scale\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('density')))\n    + geom_histogram(binwidth=0.5,\n                    fill='green',  # change the fill colour (one colour)\n                    colour='pink', # change the outline\n                    size=2,        # change the thickness of the outline\n                    alpha=0.7      # change the transparency \n                    )\n    + theme_xkcd()                 # play with themes (look/arrangement)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(diamonds, aes(x='carat', \n                         y=after_stat('density'),\n                         fill='cut'  # change the fill colour using another variable\n                        ))\n    + scale_fill_manual(values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]) # change the fill colour\n    + geom_histogram(binwidth=0.5,\n                    colour=\"#D55E00\",# change the outline\n                    size=1,          # change the thickness of the outline\n                    alpha=0.7        # change the transparency \n                    )\n    + theme_bw()                     # play with themes (look/arrangement)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('ncount'))) \n    + geom_histogram(binwidth=0.5)\n    + facet_wrap('color') # facet wrap\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x='carat', y=after_stat('ncount'))) \n    + geom_histogram(binwidth=0.5)\n    + facet_grid('cut ~ color')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "scale_x_continuous.html",
    "href": "scale_x_continuous.html",
    "title": "Guitar Neck ###",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_path,\n    scale_x_continuous,\n    scale_y_continuous,\n    guides,\n    theme,\n    element_line,\n    element_rect\n)\nfrom mizani.transforms import trans\n\nUsing a transformed x-axis to visualise guitar chords\nThe x-axis is transformed to resemble the narrowing width of frets on a 25.5 inch Strat. To do that we create custom transformation.\nThe key parts of any transform object are the transform and inverse functions.\n\nclass frets_trans(trans):\n    \"\"\"\n    Frets Transformation\n    \"\"\"\n    number_of_frets = 23               # Including fret 0\n    domain = (0, number_of_frets-1)\n    \n    @staticmethod\n    def transform(x):\n        x = np.asarray(x)\n        return 25.5 - (25.5 / (2 ** (x/12)))\n    \n    @staticmethod\n    def inverse(x):\n        x = np.asarray(x)\n        return 12 * np.log2(25.5/(25.5-x))\n    \n    @classmethod\n    def breaks_(cls, limits):\n        # Fixed major breaks\n        return cls.domain\n    \n    @classmethod\n    def minor_breaks(cls, major, limits):\n        # The major breaks as passed to this method are in transformed space.\n        # The minor breaks are calculated in data space to reveal the \n        # non-linearity of the scale.\n        _major = cls.inverse(major)\n        minor = cls.transform(np.linspace(*_major, cls.number_of_frets))\n        return minor\n\nThe above transform is different from most in that, breaks and minor breaks do not change. This is common of very specialized scales. It can also be a key requirement when creating graphics for demontration purposes.\nSome chord Data\n\n# Notes: the 0 fret is an open strum, all other frets are played half-way between fret bars.\n# The strings are 1:low E, 2: A, 3: D, 4: G, 5: B, 6: E\nc_chord = pd.DataFrame({\n    'Fret':   [0, 2.5, 1.5, 0, 0.5, 0],\n    'String': [1, 2, 3, 4, 5, 6]\n})\n\n# Sequence based on the number of notes in the chord\nc_chord['Sequence'] = list(range(1, 1+len(c_chord['Fret'])))\n\n# Standard markings for a Stratocaster\nmarkings = pd.DataFrame({\n    'Fret':   [2.5, 4.5, 6.5, 8.5, 11.5, 11.5, 14.5, 16.5, 18.5, 20.5],\n    'String': [3.5, 3.5, 3.5, 3.5, 2, 5, 3.5, 3.5, 3.5, 3.5]\n})\n\nVisualizing the chord\n\n# Look and feel of the graphic\nneck_color = '#FFDDCC'\nfret_color = '#998888'\nstring_color = '#AA9944'\n\nneck_theme = theme(\n    figure_size=(10, 2),\n    panel_background=element_rect(fill=neck_color),\n    panel_grid_major_y=element_line(color=string_color, size=2.2),\n    panel_grid_major_x=element_line(color=fret_color, size=2.2),\n    panel_grid_minor_x=element_line(color=fret_color, size=1)\n)\n\n# Gallery Plot\n\n(ggplot(c_chord, aes('Fret', 'String'))\n + geom_path(aes(color='Sequence'), size=3)\n + geom_point(aes(color='Sequence'), fill='#FFFFFF', size=3)\n + geom_point(data=markings, fill='#000000', size=4)\n + scale_x_continuous(trans=frets_trans)\n + scale_y_continuous(breaks=range(0, 7), minor_breaks=[])\n + guides(color=False)\n + neck_theme\n)\n\n\n\n\n&lt;Figure Size: (1000 x 200)&gt;\n\n\nCredit: This example was motivated by Jonathan Vitale who wanted to create graphics for a guitar scale trainer."
  },
  {
    "objectID": "geom_density.html",
    "href": "geom_density.html",
    "title": "Density Plot",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_density,\n    geom_histogram,\n    geom_vline,\n    geom_rect,\n    labs,\n    annotate,\n    theme_tufte\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nThe defaults are not exactly beautiful, but still quite clear.\n\n(ggplot(mpg, aes(x='cty'))\n + geom_density()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nPlotting multiple groups is straightforward, but as each group is plotted as an independent PDF summing to 1, the relative size of each group will be normalized.\n\n(ggplot(mpg, aes(x='cty', color='drv', fill='drv'))\n + geom_density(alpha=0.1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nTo plot multiple groups and scale them by their relative size, you can map the y aesthetic to 'count' (calculated by stat_density).\n\n(ggplot(mpg, aes(x='cty', color='drv', fill='drv'))\n + geom_density(aes(y=after_stat('count')), alpha=0.1)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\nDensity Plot + Histogram\nTo overlay a histogram onto the density, the y aesthetic of the density should be mapped to the 'count' scaled by the binwidth of the histograms.\nWhy?\nThe count calculated by stat_density is \\(count = density * n\\) where n is the number of points . The density curves have an area of 1 and have no information about the absolute frequency of the values along curve; only the relative frequencies. The count curve reveals the absolute frequencies. The scale of this count corresponds to the count calculated by the stat_bin for the histogram when the bins are 1 unit wide i.e. binwidth=1. The count * binwidth curve matches the scale of counts for the histogram for a give binwidth.\n\nbinwidth = 2  # The same for geom_density and geom_histogram\n\n(ggplot(mpg, aes(x='cty', color='drv', fill='drv'))\n + geom_density(aes(y=after_stat('count*binwidth')), alpha=0.1)\n + geom_histogram(aes(fill='drv', y=after_stat('count')), binwidth=binwidth, color='none', alpha=0.5)\n \n # It is the histogram that gives us the meaningful y axis label\n # i.e. 'count' and not 'count*2'\n + labs(y='count')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n\nShading a Region under a Density Curve\nExtending geom_density to create an effect of a shaded region\nCreate some data and plot the density\n\nn = 101\ndf = pd.DataFrame({'x': np.arange(n)})\n\n(ggplot(df, aes('x'))\n + geom_density()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nSuppose we want to mark a region as special e.g. (40, 60), we can use vertical lines to annotate it.\n\nregion = (40, 60)\n\n(ggplot(df, aes('x'))\n + geom_density()\n + annotate(geom_vline, xintercept=region)  #new line\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nTo make it standout more we can highlight. To do that, the first thought is to use a rectangle.\n\nregion = (40, 60)\n\n(ggplot(df, aes('x'))\n + geom_density()\n + annotate(geom_rect, xmin=region[0], xmax=region[1], ymin=0, ymax=float('inf'), alpha=0.5) # new line\n + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nSince y upper-bound varies along the curve, a rectangular highlight has to stretch up to the top of the panel.\nTo hightlight only within the density curve, we have to use a second density curve. We need to calculate the density as normal, but just before the curve & region are plotted, we should keep only the region we want.\nWe create our own geom_density_highlight and override the setup_data method. First, we override but do nothing, we only inspect the data to see what we have to work with.\n\n# new class\nclass geom_density_highlight(geom_density):\n    \n    def setup_data(self, data):\n        data = super().setup_data(data)\n        print(data)\n        return data\n\n\nregion = (40, 60)\n\n(ggplot(df, aes('x'))\n + geom_density()\n + geom_density_highlight(fill='black', alpha=0.5)  # new line\n + annotate(geom_vline, xintercept=region)\n)\n\n      PANEL     count   density  group    n    scaled           x         y   \n0         1  0.519038  0.005139     -1  101  0.519039    0.000000  0.005139  \\\n1         1  0.522757  0.005176     -1  101  0.522758    0.097752  0.005176   \n2         1  0.526473  0.005213     -1  101  0.526474    0.195503  0.005213   \n3         1  0.530187  0.005249     -1  101  0.530188    0.293255  0.005249   \n4         1  0.533899  0.005286     -1  101  0.533900    0.391007  0.005286   \n...     ...       ...       ...    ...  ...       ...         ...       ...   \n1019      1  0.533899  0.005286     -1  101  0.533900   99.608993  0.005286   \n1020      1  0.530187  0.005249     -1  101  0.530188   99.706745  0.005249   \n1021      1  0.526473  0.005213     -1  101  0.526474   99.804497  0.005213   \n1022      1  0.522757  0.005176     -1  101  0.522758   99.902248  0.005176   \n1023      1  0.519038  0.005139     -1  101  0.519039  100.000000  0.005139   \n\n      ymin      ymax  \n0        0  0.005139  \n1        0  0.005176  \n2        0  0.005213  \n3        0  0.005249  \n4        0  0.005286  \n...    ...       ...  \n1019     0  0.005286  \n1020     0  0.005249  \n1021     0  0.005213  \n1022     0  0.005176  \n1023     0  0.005139  \n\n[1024 rows x 10 columns]\n\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe highlight has filled the whole region, but the printed data suggests that we can limit the rows to those where x column is within our region.\n\nclass geom_density_highlight(geom_density):\n    \n    # new method\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n    \n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f'{self.region[0]} &lt;= x &lt;= {self.region[1]}'  # new line\n        data = data.query(s).reset_index(drop=True)       # new line\n        return data\n\n    \nregion = (40, 60)\n\n(ggplot(df, aes('x'))\n + geom_density()\n + geom_density_highlight(region=region, fill='black', alpha=0.5) # modified line\n + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThat is it, but we can make it look better.\n\nclass geom_density_highlight(geom_density):\n\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n    \n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f'{self.region[0]} &lt;= x &lt;= {self.region[1]}'\n        data = data.query(s).reset_index(drop=True)\n        return data\n\n\nregion = (40, 60)\nteal = '#029386'\n\n# Gallery Plot\n\n(ggplot(df, aes('x'))\n + geom_density_highlight(region=region, fill=teal+'88', color='none')\n + geom_density(fill=teal+'44', color=teal, size=.7)\n + annotate(geom_vline, xintercept=region, color=teal, size=.7)\n + theme_tufte()\n)\n\n\n\n\nShading a region under a density curve\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThis example was motivated by a question from github user Rishika-Ravindran."
  },
  {
    "objectID": "geom_line.html",
    "href": "geom_line.html",
    "title": "Line plots",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_line,\n    labs,\n    arrow\n)\nfrom plotnine.data import economics\n\ngeom_line() connects the dots, and is useful for time series data.\n\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\n\n(\n    ggplot(economics, aes(x='date', y='uempmed')) \n    + geom_line() # line plot\n    + labs(x='date', y='median duration of unemployment')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can put arrows at the end of a line:\n\n(\n    ggplot(economics, aes(x='date', y='pop')) \n    + geom_line(arrow=arrow()) # add an arrow to the end of the line\n    + labs(x='date', y='total population (,000)')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe arrow can be modified for a different look:\n\n(\n    ggplot(economics, aes(x='date', y='pop')) \n    + geom_line(arrow=arrow(angle=35,      # defines the shape of the arrow head\n                              ends=\"both\",   # input what end to put the arrow on\n                              type=\"closed\", # defines arrow head type\n                             )) \n    + labs(x='date', y='total population (,000)')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can change the look of the line:\n\n(\n    ggplot(economics, aes(x='date', y='uempmed')) \n    + geom_line(color='pink',        # set line colour\n                  size=7,            # set line thickness\n                  linetype='dashed'  # set line type\n               )\n    + labs(x='date', y='median duration of unemployment')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_path.html",
    "href": "geom_path.html",
    "title": "Path plots",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_line,\n    labs,\n    scale_color_continuous,\n    element_text,\n    theme\n)\nfrom plotnine.data import economics\n\ngeom_path() connects the observations in the order in which they appear in the data, this is different from geom_line() which connects observations in order of the variable on the x axis.\n\neconomics.head(10) # notice the rows are ordered by date\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n5\n1967-12-01\n525.8\n199657\n12.1\n4.8\n3018\n\n\n6\n1968-01-01\n531.5\n199808\n11.7\n5.1\n2878\n\n\n7\n1968-02-01\n534.2\n199920\n12.2\n4.5\n3001\n\n\n8\n1968-03-01\n544.9\n200056\n11.6\n4.1\n2877\n\n\n9\n1968-04-01\n544.6\n200208\n12.2\n4.6\n2709\n\n\n\n\n\n\n\nBecause the data is in date order geom_path() (in pint) produces the same result as geom_line() (in black):\n\n(\n    ggplot(economics, aes(x='date', y='unemploy')) \n    + geom_line(size=5)             # plot geom_line as the first layer                   \n    + geom_path(colour='#ff69b4',   # plot a path - colour pink \n               size=1)   \n    + labs(x='date', y='unemployment (,000)') # label x & y-axis\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nPlotting unemployment (scaled by population) versus savings rate shows how geom_path() differs from geom_line(). Because geom_path() connects the observations in the order in which they appear in the data, this line is like a “journey through time”:\n\n(\n    ggplot(economics, aes(x='unemploy/pop', y='psavert')) \n    + geom_path()                                    # plot geom path\n    + labs(x='scaled unemployment', y='saving rate') # label x & y-axis\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nComparing geom_line() (black) to geom_path() (pink) shows how these two plots differ in what they can show: geom_path() shows the savings rate has gone down over time, which is not evident with geom_path().\n\n(\n    ggplot(economics, aes(x='unemploy/pop', y='psavert')) \n    + geom_path(colour='#ff69b4', # plot geom_path as the first layer - colour pink\n                alpha=0.5,        # line transparency\n                size=2.5)         # line thickness\n    + geom_line()                   # layer geom_line \n    + labs(x='scaled unemployment', y='saving rate') # label x & y-axis\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe geom_path can be easier to interpret if time is coloured in. First convert time to a number, and use this number to colour the path:\n\n# convert date to a number \neconomics['date_as_number']=pd.to_numeric(economics['date'])\n\n\n# inspect new column\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\ndate_as_number\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n-79056000000000000\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n-76377600000000000\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n-73699200000000000\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n-71107200000000000\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n-68428800000000000\n\n\n\n\n\n\n\nThe path is coloured such that it changes with time using the command aes(colour='date_as_number') within geom_path().\n\n# input\nlegend_breaks=[-79056000000000000, 709948800000000000, 1401580800000000000] # used to modify colour-graded legend\nlegend_labels=[\"1967-Jul\", \"1992-Jun\",\"2014-Jun\"]\n\n# plot\n(\n    ggplot(economics, aes(x='unemploy/pop', y='psavert')) \n    + geom_path(aes(colour='date_as_number'))       # colour geom_path using time variable \"date_as_number\"\n    + labs(x='scaled unemployment', y='saving rate')\n    + scale_color_continuous(breaks=legend_breaks,  # set legend breaks (where labels will appear)\n                            labels=legend_labels)   # set labels on legend\n    + theme(legend_title=element_text(text='Date')) # set title of legend\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_step.html",
    "href": "geom_step.html",
    "title": "Step plots",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_step,\n    geom_line,\n    labs,\n    theme,\n    element_text\n)\nfrom plotnine.data import economics\n\ngeom_step() connects points using ‘steps’ instead of a line.\n\n# inspect the data\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nPlot a step plot using geom_plot(). Notice from the first point the line travels vertically then horizontally:\n\n(\n    ggplot(economics.iloc[:20],                 # filter for first twenty rows (dates) to make steps more visible\n           aes('date', 'unemploy')) \n    + geom_step()                               # step plot\n    + labs(x='date', y='unemployment (,000)')   # label x & y-axis\n    + theme(axis_text_x=element_text(angle=45)) # rotate x-axis text for readability\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can see how geom_path() (shown in pink) differs from geom_line() (black):\n\n(\n    ggplot(economics.iloc[:20], \n           aes('date', 'unemploy')) \n    + geom_step(colour='#ff69b4',              # plot geom_step as the first layer - colour pink\n                alpha=0.5,                     # line transparency\n                size=2.5)                      # line thickness\n    + geom_line()                              # plot geom_line as the second layer\n    + labs(x='date', y='unemployment (,000)')\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nRather than a line that travels vertically then horizontally, this order can be switched by specifying direction='vh' within geom_step(). Below direction='vh' is shown in black with the default direction='hv' shown in pink:\n\n(\n    ggplot(economics.iloc[:20], \n           aes('date', 'unemploy')) \n    + geom_step(colour='#ff69b4', # plot geom_path with default direction as the first layer - colour pink\n                linetype='dashed',# line type\n                size=2,           # line thickness\n                alpha=0.5)        # line transparency        \n    + geom_step(direction='vh')   # plot geom_path with step order reversed\n    + labs(x='date', y='unemployment (,000)')\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_abline.html",
    "href": "geom_abline.html",
    "title": "AB line",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    labs,\n    geom_abline,\n    facet_grid\n)\nfrom plotnine.data import mpg\n\ngeom_abline() draws a line when the yintercept and gradient is supplied, and is useful as a guide.\n\n# inspect the data\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_abline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nNow layer a line over the scatter plot using geom_abline(). geom_abline() requires inputs for the slope (default slope is 1) and y-intercept (default value is [0,0]).\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_abline(intercept=45, # set the y-intercept value\n                  slope=-5      # set the slope value\n                 ) \n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can plot two lines on one plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()                   \n    + geom_abline(intercept=[45,45], # add many lines to a plot using a list for the y-intercepts...\n                  slope=[-5,-7]      # ... and for the slopes\n                 )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_abline(intercept=45,\n                  slope=-5,\n                  color='blue',      # set line colour\n                  size=2,            # set line thickness\n                  linetype=\"dashed\"  # set line type\n                 )\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\ngeom_abline() can be used with a facet plot:\n\n(\n    ggplot(mpg, aes(x='displ', y='hwy')) \n    + geom_point()\n    + geom_abline(intercept=45,slope=-5)     # add a line ...\n    + facet_grid('drv ~ .')                  # ... to a facet plot.\n    + labs(x='displacement', y='horsepower')\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "PlotnineAnimation.html",
    "href": "PlotnineAnimation.html",
    "title": "Spiral Animation ###",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    theme,\n    theme_void,\n    lims\n)\nfrom plotnine.animation import PlotnineAnimation\n\n# for animation in the notebook\nfrom matplotlib import rc\nrc('animation', html='html5')\n\nHow to create Animations\nThe PlotnineAnimation methods takes a sequence of plots and animates them. The best way to create the sequence is to use a function that generates plots.\nNOTE: When creating the plots make sure all the plots have scales with the same limits for each aesthetic, including the x and y aesthetics.\n\n# Parameters used to control the spiral\nn = 100\ntightness = 1.3\nkmin = 1\nkmax = 25\nnum_frames = 25\ntheta = np.linspace(-np.pi, np.pi, n)\n\ndef plot(k):\n    # For every plot we change the theta\n    _theta = theta*k\n    \n    # Polar Equation of each spiral\n    r = tightness*_theta\n    \n    df = pd.DataFrame({\n        'theta': _theta,\n        'r': r,\n        'x': r*np.sin(_theta),\n        'y': r*np.cos(_theta)\n    })\n\n    p = (ggplot(df)\n         + geom_path(aes('x', 'y', color='theta'), size=1)\n         + lims(\n             # All the plots have scales with the same limits\n             x=(-130, 130),\n             y=(-130, 130),\n             color=(-kmax*np.pi, kmax*np.pi)\n         )\n         + theme_void()\n         + theme(\n             aspect_ratio=1,\n             # Make room on the right for the legend\n             subplots_adjust={'right': 0.85}\n         )\n    )\n    return p\n\n# It is better to use a generator instead of a list\nplots = (plot(k) for k in np.linspace(kmin, kmax, num_frames))\nani = PlotnineAnimation(plots, interval=100, repeat_delay=500)\n# ani.save('/tmp/animation.mp4')\nani\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nThe final image of the spiral\n\nplot(kmax)\n\n\n\n\nSpiral Animation\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_segment.html",
    "href": "geom_segment.html",
    "title": "Ranges of Similar Variables",
    "section": "",
    "text": "# NOTE: This notebook uses the polars package\nimport pandas as pd\nimport pandas.api.types as pdtypes\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\nComparing the point to point difference of many similar variables\nRead the data.\nSource: Pew Research Global Attitudes Spring 2015\n\n!head -n 20 'data/survey-social-media.csv'\n\nPSRAID,COUNTRY,Q145,Q146,Q70,Q74\n100000,Ethiopia,Female,35,No, \n100001,Ethiopia,Female,25,No, \n100002,Ethiopia,Male,40,Don’t know, \n100003,Ethiopia,Female,30,Don’t know, \n100004,Ethiopia,Male,22,No, \n100005,Ethiopia,Male,40,No, \n100006,Ethiopia,Female,20,No, \n100007,Ethiopia,Female,18,No,No\n100008,Ethiopia,Male,50,No, \n100009,Ethiopia,Male,35,No, \n100010,Ethiopia,Female,20,No, \n100011,Ethiopia,Female,30,Don’t know, \n100012,Ethiopia,Male,60,No, \n100013,Ethiopia,Male,18,No, \n100014,Ethiopia,Male,40,No, \n100015,Ethiopia,Male,28,Don’t know, \n100016,Ethiopia,Female,55,Don’t know, \n100017,Ethiopia,Male,30,Don’t know, \n100018,Ethiopia,Female,22,No, \n\n\n\ncolumns = dict(\n    COUNTRY='country',\n    Q145='gender',\n    Q146='age',\n    Q70='use_internet',\n    Q74='use_social_media'\n)\n\ndata = pl.scan_csv(\n    'data/survey-social-media.csv',\n    dtypes=dict(Q146=pl.Utf8),\n).rename(\n    columns\n).select([\n    'country',\n    'age',\n    'use_social_media'\n]).collect()\n\ndata.sample(10, seed=123)\n\n\n\n\nshape: (10, 3)\n\n\n\n\ncountry\n\n\nage\n\n\nuse_social_media\n\n\n\n\nstr\n\n\nstr\n\n\nstr\n\n\n\n\n\n\n\"Venezuela\"\n\n\n\"47\"\n\n\n\"Yes\"\n\n\n\n\n\"Israel\"\n\n\n\"63\"\n\n\n\" \"\n\n\n\n\n\"Germany\"\n\n\n\"60\"\n\n\n\"Yes\"\n\n\n\n\n\"France\"\n\n\n\"60\"\n\n\n\"No\"\n\n\n\n\n\"Philippines\"\n\n\n\"25\"\n\n\n\" \"\n\n\n\n\n\"China\"\n\n\n\"40\"\n\n\n\" \"\n\n\n\n\n\"Senegal\"\n\n\n\"20\"\n\n\n\" \"\n\n\n\n\n\"Argentina\"\n\n\n\"47\"\n\n\n\"Yes\"\n\n\n\n\n\"India\"\n\n\n\"53\"\n\n\n\"No\"\n\n\n\n\n\"Jordan\"\n\n\n\"24\"\n\n\n\" \"\n\n\n\n\n\n\n\nCreate age groups for users of social media\n\nyes_no = ['Yes', 'No']\nvalid_age_groups = ['18-34', '35-49', '50+']\n\nrdata = data.with_columns([\n    pl\n    .when(col('age') &lt;= '34').then('18-34')\n    .when(col('age') &lt;= '49').then('35-49')\n    .when(col('age') &lt; '98').then('50+')\n    .otherwise(\"\")\n    .alias('age_group'),\n    pl.count().over(\"country\").alias('country_count')\n]).filter(\n    col('age_group').is_in(valid_age_groups) &\n    col('use_social_media').is_in(yes_no)\n).groupby(['country', 'age_group']).agg([\n    # social media use percentage\n    ((col('use_social_media') == 'Yes').sum() * 100 / pl.count()).alias('sm_use_percent'),\n    \n    # social media question response rate\n    (col('use_social_media').is_in(yes_no).sum() * 100 / col('country_count').first()).alias('smq_response_rate')\n]).sort(['country', 'age_group'])\n\nrdata.head()\n\n\n\n\nshape: (5, 4)\n\n\n\n\ncountry\n\n\nage_group\n\n\nsm_use_percent\n\n\nsmq_response_rate\n\n\n\n\nstr\n\n\nstr\n\n\nf64\n\n\nf64\n\n\n\n\n\n\n\"Argentina\"\n\n\n\"18-34\"\n\n\n90.883191\n\n\n35.1\n\n\n\n\n\"Argentina\"\n\n\n\"35-49\"\n\n\n84.40367\n\n\n21.8\n\n\n\n\n\"Argentina\"\n\n\n\"50+\"\n\n\n67.333333\n\n\n15.0\n\n\n\n\n\"Australia\"\n\n\n\"18-34\"\n\n\n90.862944\n\n\n19.621514\n\n\n\n\n\"Australia\"\n\n\n\"35-49\"\n\n\n78.04878\n\n\n20.418327\n\n\n\n\n\n\n\nTop 14 countries by response rate to the social media question.\n\ndef col_format(name, fmt):\n    # Format useing python formating\n    # for more control over\n    return col(name).apply(lambda x: fmt.format(x=x))\n\ndef float_to_str_round(name):\n    return col_format(name, '{x:.0f}')\n\nn = 14\n\ntop = rdata.groupby('country').agg([\n    col('smq_response_rate').sum().alias('r')\n]).sort('r', reverse=True).head(n)\ntop_countries = top['country']\n\nexpr = float_to_str_round('sm_use_percent')\nexpr_pct = expr + '%'\n\npoint_data = rdata.filter(\n    col('country').is_in(top_countries)\n).with_column(\n    pl.when(col('country') == 'France').then(expr_pct).otherwise(expr).alias('sm_use_percent_str')\n)\n\npoint_data.head()\n\n\n\n\nshape: (5, 5)\n\n\n\n\ncountry\n\n\nage_group\n\n\nsm_use_percent\n\n\nsmq_response_rate\n\n\nsm_use_percent_str\n\n\n\n\nstr\n\n\nstr\n\n\nf64\n\n\nf64\n\n\nstr\n\n\n\n\n\n\n\"Australia\"\n\n\n\"18-34\"\n\n\n90.862944\n\n\n19.621514\n\n\n\"91\"\n\n\n\n\n\"Australia\"\n\n\n\"35-49\"\n\n\n78.04878\n\n\n20.418327\n\n\n\"78\"\n\n\n\n\n\"Australia\"\n\n\n\"50+\"\n\n\n48.479087\n\n\n52.390438\n\n\n\"48\"\n\n\n\n\n\"Canada\"\n\n\n\"18-34\"\n\n\n92.063492\n\n\n25.099602\n\n\n\"92\"\n\n\n\n\n\"Canada\"\n\n\n\"35-49\"\n\n\n75.925926\n\n\n21.513944\n\n\n\"76\"\n\n\n\n\n\n\n\n\nsegment_data = point_data.groupby('country').agg([\n    col('sm_use_percent').min().alias('min'),\n    col('sm_use_percent').max().alias('max'),\n]).with_column(\n    (col('max') - col('min')).alias('gap')\n).sort(\n    'gap',\n).with_columns([\n    float_to_str_round('min').alias('min_str'),\n    float_to_str_round('max').alias('max_str'),\n    float_to_str_round('gap').alias('gap_str')\n])\n\nsegment_data.head()\n\n\n\n\nshape: (5, 7)\n\n\n\n\ncountry\n\n\nmin\n\n\nmax\n\n\ngap\n\n\nmin_str\n\n\nmax_str\n\n\ngap_str\n\n\n\n\nstr\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nstr\n\n\nstr\n\n\nstr\n\n\n\n\n\n\n\"Russia\"\n\n\n76.07362\n\n\n95.151515\n\n\n19.077896\n\n\n\"76\"\n\n\n\"95\"\n\n\n\"19\"\n\n\n\n\n\"Israel\"\n\n\n55.405405\n\n\n88.311688\n\n\n32.906283\n\n\n\"55\"\n\n\n\"88\"\n\n\n\"33\"\n\n\n\n\n\"United Kingdom...\n\n\n52.74463\n\n\n86.096257\n\n\n33.351627\n\n\n\"53\"\n\n\n\"86\"\n\n\n\"33\"\n\n\n\n\n\"United States\"\n\n\n52.597403\n\n\n88.669951\n\n\n36.072548\n\n\n\"53\"\n\n\n\"89\"\n\n\n\"36\"\n\n\n\n\n\"Canada\"\n\n\n53.986333\n\n\n92.063492\n\n\n38.077159\n\n\n\"54\"\n\n\n\"92\"\n\n\n\"38\"\n\n\n\n\n\n\n\nFormat the floating point data that will be plotted into strings\nSet the order of the countries along the y-axis by setting the country variable to an ordered categorical.\n\ncountry_expr = col('country').cast(pl.Categorical)\nsegment_data = segment_data.with_column(country_expr)\npoint_data = point_data.with_columns(country_expr)\n\nFirst plot\n\n# The right column (youngest-oldest gap) location\nxgap = 112\n\n(ggplot()\n # Range strip\n + geom_segment(\n     segment_data,\n     aes(x='min', xend='max', y='country', yend='country'),\n     size=6,\n     color='#a7a9ac'\n )\n # Age group markers\n + geom_point(\n     point_data,\n     aes('sm_use_percent', 'country', color='age_group', fill='age_group'),\n     size=5,\n     stroke=0.7,\n )\n # Age group percentages\n + geom_text(\n     point_data.filter(col('age_group')==\"50+\"),\n     aes(x='sm_use_percent-2', y='country', label='sm_use_percent_str', color='age_group'),\n     size=8,\n     ha='right'\n )\n + geom_text(\n     point_data.filter(col('age_group')==\"35-49\"),\n     aes(x='sm_use_percent+2', y='country', label='sm_use_percent_str'),\n     size=8,\n     ha='left',\n     va='center',\n     color='white'\n )\n + geom_text(\n     point_data.filter(col('age_group')==\"18-34\"),\n     aes(x='sm_use_percent+2', y='country', label='sm_use_percent_str', color='age_group'),\n     size=8,\n     ha='left',\n )\n # gap difference\n + geom_text(\n     segment_data,\n     aes(x=xgap, y='country', label='gap_str'),\n     size=9,\n     fontweight='bold',\n     format_string='+{}'\n )\n)\n\n\n\n\nTweak it\n\n# The right column (youngest-oldest gap) location\nxgap = 115\n\n# Gallery Plot\n\n(ggplot()\n # Background Strips                                     # new\n + geom_segment(\n     segment_data,\n     aes(y='country', yend='country'),\n     x=0, xend=100,\n     size=8.5,\n     color='#edece3'\n )\n # vertical grid lines along the strips                  # new\n + annotate(\n     'segment',\n     x=list(range(10, 100, 10)) * n,\n     xend=list(range(10, 100, 10)) * n,\n     y=np.tile(np.arange(1, n+1), 9)-.25,\n     yend=np.tile(np.arange(1, n+1), 9) + .25,\n     color='#CCCCCC'\n )\n # Range strip\n + geom_segment(\n     segment_data,\n     aes(x='min', xend='max', y='country', yend='country'),\n     size=6,\n     color='#a7a9ac'\n )\n # Age group markers\n + geom_point(\n     point_data,\n     aes('sm_use_percent', 'country', color='age_group', fill='age_group'),\n     size=5,\n     stroke=0.7,\n )\n # Age group percentages\n + geom_text(\n     point_data.filter(col('age_group')==\"50+\"),\n     aes(x='sm_use_percent-2', y='country', label='sm_use_percent_str', color='age_group'),\n     size=8,\n     ha='right',\n )\n + geom_text(\n     point_data.filter(col('age_group')==\"35-49\"),\n     aes(x='sm_use_percent+2', y='country', label='sm_use_percent_str'),\n     size=8,\n     ha='left',\n     va='center',\n     color='white'\n )\n + geom_text(\n     point_data.filter(col('age_group')==\"18-34\"),\n     aes(x='sm_use_percent+2', y='country', label='sm_use_percent_str', color='age_group'),\n     size=8,\n     ha='left',\n )\n # countries right-hand-size (instead of y-axis)         # new\n + geom_text(\n     segment_data,\n     aes(y='country', label='country'),\n     x=-1,\n     size=8,\n     ha='right',\n     fontweight='bold',\n     color='#222222'\n )\n # gap difference\n + geom_vline(xintercept=xgap, color='#edece3', size=32)  # new\n + geom_text(\n     segment_data,\n     aes(x=xgap, y='country', label='gap_str'),\n     size=9,\n     fontweight='bold',\n     format_string='+{}'\n )\n # Annotations                                            # new\n + annotate('text', x=31, y=n+1.1, label='50+', size=9, color='#ea9f2f', va='top')\n + annotate('text', x=56, y=n+1.1, label='35-49', size=9, color='#6d6e71', va='top')\n + annotate('text', x=85, y=n+1.1, label='18-34', size=9, color='#939c49', va='top')\n + annotate('text', x=xgap, y=n+.5, label='Youngest-\\nOldest Gap', size=9, color='#444444', va='bottom', ha='center')\n + annotate('point', x=[31, 56, 85], y=n+.3, alpha=0.85, stroke=0)\n + annotate('segment', x=[31, 56, 85], xend=[31, 56, 85], y=n+.3, yend=n+.8, alpha=0.85)\n + annotate('hline', yintercept=[x+0.5 for x in range(2, n, 2)], alpha=.5, linetype='dotted', size=0.7)\n \n # Better spacing and color                              # new\n + scale_x_continuous(limits=(-18, xgap+2))\n + scale_y_discrete(expand=(0, 0.25, 0.1, 0))\n + scale_fill_manual(values=['#c3ca8c', '#d1d3d4', '#f2c480'])\n + scale_color_manual(values=['#939c49', '#6d6e71', '#ea9f2f'])\n + guides(color=None, fill=None)\n + theme_void()\n + theme(figure_size=(8, 8.5))\n)\n\n\n\n\nRanges of similar variables\n\n\n\n\nInstead of looking at this plot as having a country variable on the y-axis and a percentage variable on the x-axis, we can view it as having vertically stacked up many indepedent variables, the values of which have a similar scale.\nProtip: Save a pdf file.\n\nChange in Rank\nComparing a group of ranked items at two different times\nRead the data.\nSource: World Bank - Infanct Mortality Rate (per 1,000 live births)b\n\ndata = pl.read_csv(\n    'data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv',\n    skip_rows=4,\n    null_values=\"\",\n)\n\n# Columns as valid python variables\nyear_columns = {c: f'y{c}' for c in data.columns if c[:2] in {'19', '20'}}\ndata = data.rename({\n    'Country Name': 'country',\n    'Country Code': 'code',\n    **year_columns\n}).drop(['Indicator Name', 'Indicator Code'])\ndata.head()\n\n\n\n\nshape: (5, 59)\n\n\n\n\ncountry\n\n\ncode\n\n\ny1960\n\n\ny1961\n\n\ny1962\n\n\ny1963\n\n\ny1964\n\n\ny1965\n\n\ny1966\n\n\ny1967\n\n\ny1968\n\n\ny1969\n\n\ny1970\n\n\ny1971\n\n\ny1972\n\n\ny1973\n\n\ny1974\n\n\ny1975\n\n\ny1976\n\n\ny1977\n\n\ny1978\n\n\ny1979\n\n\ny1980\n\n\ny1981\n\n\ny1982\n\n\ny1983\n\n\ny1984\n\n\ny1985\n\n\ny1986\n\n\ny1987\n\n\ny1988\n\n\ny1989\n\n\ny1990\n\n\ny1991\n\n\ny1992\n\n\ny1993\n\n\ny1994\n\n\ny1995\n\n\ny1996\n\n\ny1997\n\n\ny1998\n\n\ny1999\n\n\ny2000\n\n\ny2001\n\n\ny2002\n\n\ny2003\n\n\ny2004\n\n\ny2005\n\n\ny2006\n\n\ny2007\n\n\ny2008\n\n\ny2009\n\n\ny2010\n\n\ny2011\n\n\ny2012\n\n\ny2013\n\n\ny2014\n\n\ny2015\n\n\ny2016\n\n\n\n\nstr\n\n\nstr\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nstr\n\n\n\n\n\n\n\"Aruba\"\n\n\n\"ABW\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n\n\n\"Afghanistan\"\n\n\n\"AFG\"\n\n\nnull\n\n\n240.5\n\n\n236.3\n\n\n232.3\n\n\n228.5\n\n\n224.6\n\n\n220.7\n\n\n217.0\n\n\n213.3\n\n\n209.8\n\n\n206.1\n\n\n202.2\n\n\n198.2\n\n\n194.3\n\n\n190.3\n\n\n186.6\n\n\n182.6\n\n\n178.7\n\n\n174.5\n\n\n170.4\n\n\n166.1\n\n\n161.8\n\n\n157.5\n\n\n153.2\n\n\n148.7\n\n\n144.5\n\n\n140.2\n\n\n135.7\n\n\n131.3\n\n\n126.8\n\n\n122.5\n\n\n118.3\n\n\n114.4\n\n\n110.9\n\n\n107.7\n\n\n105.0\n\n\n102.7\n\n\n100.7\n\n\n98.9\n\n\n97.2\n\n\n95.4\n\n\n93.4\n\n\n91.2\n\n\n89.0\n\n\n86.7\n\n\n84.4\n\n\n82.3\n\n\n80.4\n\n\n78.6\n\n\n76.8\n\n\n75.1\n\n\n73.4\n\n\n71.7\n\n\n69.9\n\n\n68.1\n\n\n66.3\n\n\nnull\n\n\n\n\n\"Angola\"\n\n\n\"AGO\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n138.3\n\n\n137.5\n\n\n136.8\n\n\n136.0\n\n\n135.3\n\n\n134.9\n\n\n134.4\n\n\n134.1\n\n\n133.8\n\n\n133.6\n\n\n133.5\n\n\n133.5\n\n\n133.5\n\n\n133.4\n\n\n133.2\n\n\n132.8\n\n\n132.3\n\n\n131.5\n\n\n130.6\n\n\n129.5\n\n\n128.3\n\n\n126.9\n\n\n125.5\n\n\n124.1\n\n\n122.8\n\n\n121.2\n\n\n119.4\n\n\n117.1\n\n\n114.7\n\n\n112.2\n\n\n109.6\n\n\n106.8\n\n\n104.1\n\n\n101.4\n\n\n98.8\n\n\n96.0\n\n\nnull\n\n\n\n\n\"Albania\"\n\n\n\"ALB\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n73.0\n\n\n68.4\n\n\n64.0\n\n\n59.9\n\n\n56.1\n\n\n52.4\n\n\n49.1\n\n\n45.9\n\n\n43.2\n\n\n40.8\n\n\n38.6\n\n\n36.7\n\n\n35.1\n\n\n33.7\n\n\n32.5\n\n\n31.4\n\n\n30.3\n\n\n29.1\n\n\n27.9\n\n\n26.8\n\n\n25.5\n\n\n24.4\n\n\n23.2\n\n\n22.1\n\n\n21.0\n\n\n20.0\n\n\n19.1\n\n\n18.3\n\n\n17.4\n\n\n16.7\n\n\n16.0\n\n\n15.4\n\n\n14.8\n\n\n14.3\n\n\n13.8\n\n\n13.3\n\n\n12.9\n\n\n12.5\n\n\nnull\n\n\n\n\n\"Andorra\"\n\n\n\"AND\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n7.5\n\n\n7.0\n\n\n6.5\n\n\n6.1\n\n\n5.6\n\n\n5.2\n\n\n5.0\n\n\n4.6\n\n\n4.3\n\n\n4.1\n\n\n3.9\n\n\n3.7\n\n\n3.5\n\n\n3.3\n\n\n3.2\n\n\n3.1\n\n\n2.9\n\n\n2.8\n\n\n2.7\n\n\n2.6\n\n\n2.5\n\n\n2.4\n\n\n2.3\n\n\n2.2\n\n\n2.1\n\n\n2.1\n\n\nnull\n\n\n\n\n\n\n\nThe data includes regional aggregates. To tell apart the regional aggregates we need the metadata. Every row in the data table has a corresponding row in the metadata table. Where the row has regional aggregate data, the Region column in the metadata table is NaN.\n\ndef ordered_categorical(s, categories=None):\n    \"\"\"\n    Create a categorical ordered according to the categories\n    \"\"\"\n    name = getattr(s, 'name', '')\n    if categories is None:\n        return pl.Series(name, s).cast(pl.Categorical)\n\n    with pl.StringCache():\n        pl.Series(categories).cast(pl.Categorical)\n        return pl.Series(name, s).cast(pl.Categorical)\n\ncolumns = {\n    'Country Code': 'code',\n    'Region': 'region',\n    'IncomeGroup': 'income_group'\n}\n\nmetadata = pl.scan_csv(\n    'data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/Metadata_Country_API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv'\n).rename(\n    columns\n).select(\n    list(columns.values())\n).filter(\n    # Drop the regional aggregate information\n    (col('region') != '') & (col('income_group') != '')\n).collect()\n\ncat_order = ['High income', 'Upper middle income', 'Lower middle income', 'Low income']\nmetadata = metadata.with_columns([\n    ordered_categorical(metadata['income_group'], cat_order)\n])\n\nmetadata.head(10)\n\n\n\n\nshape: (10, 3)\n\n\n\n\ncode\n\n\nregion\n\n\nincome_group\n\n\n\n\nstr\n\n\nstr\n\n\ncat\n\n\n\n\n\n\n\"ABW\"\n\n\n\"Latin America ...\n\n\n\"High income\"\n\n\n\n\n\"AFG\"\n\n\n\"South Asia\"\n\n\n\"Low income\"\n\n\n\n\n\"AGO\"\n\n\n\"Sub-Saharan Af...\n\n\n\"Lower middle i...\n\n\n\n\n\"ALB\"\n\n\n\"Europe & Centr...\n\n\n\"Upper middle i...\n\n\n\n\n\"AND\"\n\n\n\"Europe & Centr...\n\n\n\"High income\"\n\n\n\n\n\"ARE\"\n\n\n\"Middle East & ...\n\n\n\"High income\"\n\n\n\n\n\"ARG\"\n\n\n\"Latin America ...\n\n\n\"Upper middle i...\n\n\n\n\n\"ARM\"\n\n\n\"Europe & Centr...\n\n\n\"Lower middle i...\n\n\n\n\n\"ASM\"\n\n\n\"East Asia & Pa...\n\n\n\"Upper middle i...\n\n\n\n\n\"ATG\"\n\n\n\"Latin America ...\n\n\n\"High income\"\n\n\n\n\n\n\n\nRemove the regional aggregates, to create a table with only country data\n\ncountry_data = data.join(metadata, on='code')\ncountry_data.head()\n\n\n\n\nshape: (5, 61)\n\n\n\n\ncountry\n\n\ncode\n\n\ny1960\n\n\ny1961\n\n\ny1962\n\n\ny1963\n\n\ny1964\n\n\ny1965\n\n\ny1966\n\n\ny1967\n\n\ny1968\n\n\ny1969\n\n\ny1970\n\n\ny1971\n\n\ny1972\n\n\ny1973\n\n\ny1974\n\n\ny1975\n\n\ny1976\n\n\ny1977\n\n\ny1978\n\n\ny1979\n\n\ny1980\n\n\ny1981\n\n\ny1982\n\n\ny1983\n\n\ny1984\n\n\ny1985\n\n\ny1986\n\n\ny1987\n\n\ny1988\n\n\ny1989\n\n\ny1990\n\n\ny1991\n\n\ny1992\n\n\ny1993\n\n\ny1994\n\n\ny1995\n\n\ny1996\n\n\ny1997\n\n\ny1998\n\n\ny1999\n\n\ny2000\n\n\ny2001\n\n\ny2002\n\n\ny2003\n\n\ny2004\n\n\ny2005\n\n\ny2006\n\n\ny2007\n\n\ny2008\n\n\ny2009\n\n\ny2010\n\n\ny2011\n\n\ny2012\n\n\ny2013\n\n\ny2014\n\n\ny2015\n\n\ny2016\n\n\nregion\n\n\nincome_group\n\n\n\n\nstr\n\n\nstr\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nstr\n\n\nstr\n\n\ncat\n\n\n\n\n\n\n\"Aruba\"\n\n\n\"ABW\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n\"Latin America ...\n\n\n\"High income\"\n\n\n\n\n\"Afghanistan\"\n\n\n\"AFG\"\n\n\nnull\n\n\n240.5\n\n\n236.3\n\n\n232.3\n\n\n228.5\n\n\n224.6\n\n\n220.7\n\n\n217.0\n\n\n213.3\n\n\n209.8\n\n\n206.1\n\n\n202.2\n\n\n198.2\n\n\n194.3\n\n\n190.3\n\n\n186.6\n\n\n182.6\n\n\n178.7\n\n\n174.5\n\n\n170.4\n\n\n166.1\n\n\n161.8\n\n\n157.5\n\n\n153.2\n\n\n148.7\n\n\n144.5\n\n\n140.2\n\n\n135.7\n\n\n131.3\n\n\n126.8\n\n\n122.5\n\n\n118.3\n\n\n114.4\n\n\n110.9\n\n\n107.7\n\n\n105.0\n\n\n102.7\n\n\n100.7\n\n\n98.9\n\n\n97.2\n\n\n95.4\n\n\n93.4\n\n\n91.2\n\n\n89.0\n\n\n86.7\n\n\n84.4\n\n\n82.3\n\n\n80.4\n\n\n78.6\n\n\n76.8\n\n\n75.1\n\n\n73.4\n\n\n71.7\n\n\n69.9\n\n\n68.1\n\n\n66.3\n\n\nnull\n\n\n\"South Asia\"\n\n\n\"Low income\"\n\n\n\n\n\"Angola\"\n\n\n\"AGO\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n138.3\n\n\n137.5\n\n\n136.8\n\n\n136.0\n\n\n135.3\n\n\n134.9\n\n\n134.4\n\n\n134.1\n\n\n133.8\n\n\n133.6\n\n\n133.5\n\n\n133.5\n\n\n133.5\n\n\n133.4\n\n\n133.2\n\n\n132.8\n\n\n132.3\n\n\n131.5\n\n\n130.6\n\n\n129.5\n\n\n128.3\n\n\n126.9\n\n\n125.5\n\n\n124.1\n\n\n122.8\n\n\n121.2\n\n\n119.4\n\n\n117.1\n\n\n114.7\n\n\n112.2\n\n\n109.6\n\n\n106.8\n\n\n104.1\n\n\n101.4\n\n\n98.8\n\n\n96.0\n\n\nnull\n\n\n\"Sub-Saharan Af...\n\n\n\"Lower middle i...\n\n\n\n\n\"Albania\"\n\n\n\"ALB\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n73.0\n\n\n68.4\n\n\n64.0\n\n\n59.9\n\n\n56.1\n\n\n52.4\n\n\n49.1\n\n\n45.9\n\n\n43.2\n\n\n40.8\n\n\n38.6\n\n\n36.7\n\n\n35.1\n\n\n33.7\n\n\n32.5\n\n\n31.4\n\n\n30.3\n\n\n29.1\n\n\n27.9\n\n\n26.8\n\n\n25.5\n\n\n24.4\n\n\n23.2\n\n\n22.1\n\n\n21.0\n\n\n20.0\n\n\n19.1\n\n\n18.3\n\n\n17.4\n\n\n16.7\n\n\n16.0\n\n\n15.4\n\n\n14.8\n\n\n14.3\n\n\n13.8\n\n\n13.3\n\n\n12.9\n\n\n12.5\n\n\nnull\n\n\n\"Europe & Centr...\n\n\n\"Upper middle i...\n\n\n\n\n\"Andorra\"\n\n\n\"AND\"\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\nnull\n\n\n7.5\n\n\n7.0\n\n\n6.5\n\n\n6.1\n\n\n5.6\n\n\n5.2\n\n\n5.0\n\n\n4.6\n\n\n4.3\n\n\n4.1\n\n\n3.9\n\n\n3.7\n\n\n3.5\n\n\n3.3\n\n\n3.2\n\n\n3.1\n\n\n2.9\n\n\n2.8\n\n\n2.7\n\n\n2.6\n\n\n2.5\n\n\n2.4\n\n\n2.3\n\n\n2.2\n\n\n2.1\n\n\n2.1\n\n\nnull\n\n\n\"Europe & Centr...\n\n\n\"High income\"\n\n\n\n\n\n\n\nWe are interested in the changes in rank between 1960 and 2015. To plot a reasonable sized graph, we randomly sample 35 countries.\n\nsampled_data = country_data.drop_nulls(\n    subset=['y1960', 'y2015']\n).sample(\n    n=35,\n    seed=123\n).with_columns([\n    col('y1960').rank(method='ordinal').cast(pl.Int64).suffix('_rank'),\n    col('y2015').rank(method='ordinal').cast(pl.Int64).suffix('_rank')\n]).sort('y2015_rank', reverse=True)\n\nsampled_data.head()\n\n\n\n\nshape: (5, 63)\n\n\n\n\ncountry\n\n\ncode\n\n\ny1960\n\n\ny1961\n\n\ny1962\n\n\ny1963\n\n\ny1964\n\n\ny1965\n\n\ny1966\n\n\ny1967\n\n\ny1968\n\n\ny1969\n\n\ny1970\n\n\ny1971\n\n\ny1972\n\n\ny1973\n\n\ny1974\n\n\ny1975\n\n\ny1976\n\n\ny1977\n\n\ny1978\n\n\ny1979\n\n\ny1980\n\n\ny1981\n\n\ny1982\n\n\ny1983\n\n\ny1984\n\n\ny1985\n\n\ny1986\n\n\ny1987\n\n\ny1988\n\n\ny1989\n\n\ny1990\n\n\ny1991\n\n\ny1992\n\n\ny1993\n\n\ny1994\n\n\ny1995\n\n\ny1996\n\n\ny1997\n\n\ny1998\n\n\ny1999\n\n\ny2000\n\n\ny2001\n\n\ny2002\n\n\ny2003\n\n\ny2004\n\n\ny2005\n\n\ny2006\n\n\ny2007\n\n\ny2008\n\n\ny2009\n\n\ny2010\n\n\ny2011\n\n\ny2012\n\n\ny2013\n\n\ny2014\n\n\ny2015\n\n\ny2016\n\n\nregion\n\n\nincome_group\n\n\ny1960_rank\n\n\ny2015_rank\n\n\n\n\nstr\n\n\nstr\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nf64\n\n\nstr\n\n\nstr\n\n\ncat\n\n\ni64\n\n\ni64\n\n\n\n\n\n\n\"Togo\"\n\n\n\"TGO\"\n\n\n162.4\n\n\n159.4\n\n\n156.4\n\n\n153.5\n\n\n150.5\n\n\n147.7\n\n\n144.7\n\n\n141.8\n\n\n138.8\n\n\n135.8\n\n\n132.8\n\n\n130.0\n\n\n127.2\n\n\n124.4\n\n\n121.8\n\n\n119.2\n\n\n116.6\n\n\n114.1\n\n\n111.7\n\n\n109.2\n\n\n106.9\n\n\n104.8\n\n\n102.7\n\n\n100.7\n\n\n98.9\n\n\n97.1\n\n\n95.5\n\n\n94.0\n\n\n92.6\n\n\n91.4\n\n\n90.2\n\n\n89.0\n\n\n87.9\n\n\n86.8\n\n\n85.5\n\n\n84.2\n\n\n82.8\n\n\n81.2\n\n\n79.6\n\n\n77.9\n\n\n76.2\n\n\n74.4\n\n\n72.6\n\n\n70.8\n\n\n69.1\n\n\n67.4\n\n\n65.7\n\n\n64.1\n\n\n62.5\n\n\n60.9\n\n\n59.3\n\n\n57.9\n\n\n56.5\n\n\n55.0\n\n\n53.6\n\n\n52.3\n\n\nnull\n\n\n\"Sub-Saharan Af...\n\n\n\"Low income\"\n\n\n33\n\n\n35\n\n\n\n\n\"Haiti\"\n\n\n\"HTI\"\n\n\n194.8\n\n\n191.5\n\n\n188.3\n\n\n185.2\n\n\n182.2\n\n\n179.1\n\n\n176.0\n\n\n172.9\n\n\n169.8\n\n\n166.6\n\n\n163.4\n\n\n160.1\n\n\n156.6\n\n\n153.0\n\n\n149.5\n\n\n146.0\n\n\n142.6\n\n\n139.2\n\n\n135.8\n\n\n132.5\n\n\n129.4\n\n\n126.2\n\n\n123.0\n\n\n120.0\n\n\n117.1\n\n\n114.3\n\n\n111.5\n\n\n108.8\n\n\n106.1\n\n\n103.5\n\n\n101.0\n\n\n98.4\n\n\n95.8\n\n\n93.1\n\n\n90.4\n\n\n87.8\n\n\n85.1\n\n\n82.4\n\n\n79.9\n\n\n77.4\n\n\n75.0\n\n\n72.8\n\n\n70.7\n\n\n68.9\n\n\n67.2\n\n\n65.6\n\n\n64.1\n\n\n62.7\n\n\n61.3\n\n\n60.0\n\n\n85.5\n\n\n57.5\n\n\n56.2\n\n\n54.8\n\n\n53.5\n\n\n52.2\n\n\nnull\n\n\n\"Latin America ...\n\n\n\"Low income\"\n\n\n35\n\n\n34\n\n\n\n\n\"Gambia, The\"\n\n\n\"GMB\"\n\n\n148.4\n\n\n146.1\n\n\n143.8\n\n\n141.5\n\n\n139.3\n\n\n137.1\n\n\n134.9\n\n\n132.6\n\n\n130.5\n\n\n128.3\n\n\n126.0\n\n\n123.8\n\n\n121.5\n\n\n119.1\n\n\n116.7\n\n\n114.4\n\n\n112.1\n\n\n109.8\n\n\n107.6\n\n\n105.4\n\n\n103.2\n\n\n100.9\n\n\n98.6\n\n\n96.2\n\n\n93.7\n\n\n91.3\n\n\n88.9\n\n\n86.5\n\n\n84.3\n\n\n82.1\n\n\n80.0\n\n\n78.0\n\n\n76.1\n\n\n74.3\n\n\n72.6\n\n\n70.9\n\n\n69.3\n\n\n67.7\n\n\n66.2\n\n\n64.8\n\n\n63.3\n\n\n62.0\n\n\n60.6\n\n\n59.3\n\n\n58.0\n\n\n56.8\n\n\n55.6\n\n\n54.5\n\n\n53.6\n\n\n52.6\n\n\n51.7\n\n\n50.9\n\n\n50.1\n\n\n49.4\n\n\n48.6\n\n\n47.9\n\n\nnull\n\n\n\"Sub-Saharan Af...\n\n\n\"Low income\"\n\n\n32\n\n\n33\n\n\n\n\n\"Zimbabwe\"\n\n\n\"ZWE\"\n\n\n92.6\n\n\n90.1\n\n\n87.6\n\n\n85.3\n\n\n82.8\n\n\n80.5\n\n\n78.3\n\n\n76.3\n\n\n74.7\n\n\n73.4\n\n\n72.4\n\n\n71.6\n\n\n71.1\n\n\n70.7\n\n\n70.5\n\n\n70.3\n\n\n70.1\n\n\n69.8\n\n\n69.2\n\n\n68.1\n\n\n66.4\n\n\n64.2\n\n\n61.6\n\n\n58.8\n\n\n56.0\n\n\n53.6\n\n\n51.7\n\n\n50.4\n\n\n49.8\n\n\n50.2\n\n\n51.2\n\n\n52.6\n\n\n54.5\n\n\n56.4\n\n\n58.1\n\n\n60.1\n\n\n61.6\n\n\n62.7\n\n\n63.3\n\n\n63.5\n\n\n63.5\n\n\n63.2\n\n\n62.7\n\n\n61.9\n\n\n61.5\n\n\n61.0\n\n\n60.3\n\n\n59.9\n\n\n58.9\n\n\n57.7\n\n\n55.8\n\n\n54.0\n\n\n49.4\n\n\n48.8\n\n\n47.6\n\n\n46.6\n\n\nnull\n\n\n\"Sub-Saharan Af...\n\n\n\"Low income\"\n\n\n19\n\n\n32\n\n\n\n\n\"Zambia\"\n\n\n\"ZMB\"\n\n\n123.2\n\n\n120.9\n\n\n118.7\n\n\n116.7\n\n\n115.1\n\n\n114.0\n\n\n113.3\n\n\n112.9\n\n\n112.2\n\n\n111.1\n\n\n109.3\n\n\n106.7\n\n\n103.7\n\n\n100.7\n\n\n98.1\n\n\n96.3\n\n\n95.3\n\n\n95.1\n\n\n95.3\n\n\n95.6\n\n\n96.1\n\n\n97.0\n\n\n98.3\n\n\n100.2\n\n\n102.7\n\n\n105.6\n\n\n108.3\n\n\n110.6\n\n\n112.2\n\n\n113.1\n\n\n113.3\n\n\n113.0\n\n\n112.4\n\n\n111.3\n\n\n109.7\n\n\n107.8\n\n\n106.1\n\n\n104.6\n\n\n103.1\n\n\n100.9\n\n\n97.6\n\n\n92.7\n\n\n86.5\n\n\n80.0\n\n\n73.9\n\n\n68.7\n\n\n64.9\n\n\n61.3\n\n\n58.7\n\n\n55.6\n\n\n52.9\n\n\n51.1\n\n\n49.0\n\n\n46.5\n\n\n44.7\n\n\n43.3\n\n\nnull\n\n\n\"Sub-Saharan Af...\n\n\n\"Lower middle i...\n\n\n23\n\n\n31\n\n\n\n\n\n\n\nFirst graph\n\n(ggplot(sampled_data)\n + geom_text(aes(1, 'y1960_rank', label='country'), ha='right', size=9)\n + geom_text(aes(2, 'y2015_rank', label='country'), ha='left', size=9)\n + geom_point(aes(1, 'y1960_rank', color='income_group'), size=2.5)\n + geom_point(aes(2, 'y2015_rank', color='income_group'), size=2.5)\n + geom_segment(aes(x=1, y='y1960_rank', xend=2, yend='y2015_rank', color='income_group'))\n + scale_y_reverse()\n)\n\n\n\n\nChange in Rank\n\n\n\n\nIt has the form we want, but we need to tweak it.\n\n# Text colors\nblack1 = '#252525'\nblack2 = '#222222'\n\n# Gallery Plot\n\n(ggplot(sampled_data)\n # Slight modifications for the original lines,\n # 1. Nudge the text to either sides of the points\n # 2. Alter the color and alpha values\n + geom_text(aes(1, 'y1960_rank', label='country'), nudge_x=-0.05, ha='right', size=9, color=black1)\n + geom_text(aes(2, 'y2015_rank', label='country'), nudge_x=0.05, ha='left', size=9, color=black1)\n + geom_point(aes(1, 'y1960_rank', color='income_group'), size=2.5, alpha=.7)\n + geom_point(aes(2, 'y2015_rank', color='income_group'), size=2.5, alpha=.7)\n + geom_segment(aes(x=1, y='y1960_rank', xend=2, yend='y2015_rank', color='income_group'), alpha=.7)\n \n # Text Annotations\n #+ annotate('text', x=1, y=0, label='Rank in 1960', fontweight='bold', ha='right', size=10, color=black2)\n #+ annotate('text', x=2, y=0, label='Rank in 2015', fontweight='bold', ha='left', size=10, color=black2)\n + annotate('text', x=1.5, y=0, label='Lines show change in rank', size=9, color=black1)\n #+ annotate('label', x=1.5, y=3, label='Lower infant\\ndeath rates', size=9, color=black1,\n #           label_size=0, fontstyle='italic')\n #+ annotate('label', x=1.5, y=33, label='Higher infant\\ndeath rates', size=9, color=black1,\n #           label_size=0, fontstyle='italic')\n \n # Prevent country names from being chopped off\n + lims(x=(0.35, 2.65))\n + labs(color='Income Group')\n # Countries with lower rates on top\n + scale_y_reverse()\n # Change colors\n + scale_color_brewer(type='qual', palette=2)\n # Removes all decorations\n + theme_void()\n # Changing the figure size prevents the country names from squishing up\n + theme(figure_size=(8, 11))\n)"
  },
  {
    "objectID": "aes.html",
    "href": "aes.html",
    "title": "aes",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point\n)\n\nMapping variables to the visual properties of a plot.\n\ndf = pd.DataFrame({\n    'col1': np.arange(11),\n    'col2': np.arange(11)\n})\n\n(ggplot(df, aes(x='col1', y='col2'))\n + geom_point()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n(ggplot(df, aes(x='col1', y='col2 ** 2'))\n + geom_point()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\n(ggplot(df, aes(x='col1', y='np.square(col2)'))\n + geom_point()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe first two positional arguments are x and y aesthetics. Any other aesthetic must be mapped with a keyword argument.\n\n(ggplot(df, aes('col1', 'np.square(col2)', color='col2'))\n + geom_point(size=3)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;"
  },
  {
    "objectID": "geom_map.html",
    "href": "geom_map.html",
    "title": "The Political Territories of Westeros",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gp\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    coord_cartesian,\n    element_rect,\n    theme_void,\n    theme\n)\n\nLayering different features on a Map\nRead data and select features in Westeros only.\n\ncontinents = gp.read_file('data/lands-of-ice-and-fire/continents.shp')\nislands = gp.read_file('data/lands-of-ice-and-fire/islands.shp')\nlakes = gp.read_file('data/lands-of-ice-and-fire/lakes.shp')\nrivers = gp.read_file('data/lands-of-ice-and-fire/rivers.shp')\npolitical = gp.read_file('data/lands-of-ice-and-fire/political.shp')\nwall = gp.read_file('data/lands-of-ice-and-fire/wall.shp')\nroads = gp.read_file('data/lands-of-ice-and-fire/roads.shp')\nlocations = gp.read_file('data/lands-of-ice-and-fire/locations.shp')\n\nwesteros = continents.query('name==\"Westeros\"')\nislands = islands.query('continent==\"Westeros\" and name!=\"Summer Islands\"')\nlakes = lakes.query('continent==\"Westeros\"')\nrivers = rivers.query('continent==\"Westeros\"')\nroads = roads.query('continent==\"Westeros\"')\n\nwg = westeros.geometry[0]\nbool_idx = [wg.contains(g) for g in locations.geometry]\nwesteros_locations = locations[bool_idx]\ncities = westeros_locations[westeros_locations['type'] == 'City'].copy()\n\nCreate map by placing the features in layers in an order that limits obstraction.\nThe GeoDataFrame.geometry.centroid property has the center coordinates of polygons, we use these to place the labels of the political regions.\n\n# colors\nwater_color = '#a3ccff'\nwall_color = 'white'\nroad_color = 'brown'\n\n# Create label text by merging the territory name and\n# the claimant to the territory\ndef fmt_labels(names, claimants):\n    labels = []\n    for name, claimant in zip(names, claimants):\n        if name:\n            labels.append('{} ({})'.format(name, claimant))\n        else:\n            labels.append('({})'.format(claimant))\n    return labels\n\n\ndef calculate_center(df):\n    \"\"\"\n    Calculate the centre of a geometry\n    \n    This method first converts to a planar crs, gets the centroid\n    then converts back to the original crs. This gives a more\n    accurate\n    \"\"\"\n    original_crs = df.crs\n    planar_crs = 'EPSG:3857'\n    return df['geometry'].to_crs(planar_crs).centroid.to_crs(original_crs)\n\n\npolitical['center'] = calculate_center(political)\ncities['center'] = calculate_center(cities)\n\n# Gallery Plot\n\n(ggplot()\n + geom_map(westeros, fill=None)\n + geom_map(islands, fill=None)\n + geom_map(political, aes(fill='ClaimedBy'), color=None, show_legend=False)\n + geom_map(wall, color=wall_color, size=2)\n + geom_map(lakes, fill=water_color, color=None)\n + geom_map(rivers, aes(size='size'), color=water_color, show_legend=False)\n + geom_map(roads, aes(size='size'), color=road_color, alpha=0.5, show_legend=False)\n + geom_map(cities, size=1)\n + geom_text(\n     political,\n     aes('center.x', 'center.y', label='fmt_labels(name, ClaimedBy)'),\n     size=8,\n     fontweight='bold'\n )\n + geom_text(\n     cities,\n     aes('center.x', 'center.y', label='name'),\n     size=8,\n     ha='left',\n     nudge_x=.20\n )\n + labs(title=\"The Political Territories of Westeros\")\n + scale_fill_brewer(type='qual', palette=8)\n + scale_x_continuous(expand=(0, 0, 0, 1))\n + scale_y_continuous(expand=(0, 1, 0, 0))\n + scale_size_continuous(range=(0.4, 1))\n + coord_cartesian()\n + theme_void()\n + theme(figure_size=(8, 12), panel_background=element_rect(fill=water_color))\n)\n\n\n\n\nThe political territories of Westeros\n\n\n\n\n&lt;Figure Size: (800 x 1200)&gt;\n\n\nCredit: cadaei of the cartographersguild website forum."
  },
  {
    "objectID": "geom_tile.html",
    "href": "geom_tile.html",
    "title": "Periodic Table of Elements",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\nGraphing of highly organised tabular information\nRead the data.\n\nelements = pd.read_csv('data/elements.csv')\nelements.head()\n\n\n\n\n\n\n\n\natomic number\nsymbol\nname\natomic mass\nCPK\nelectronic configuration\nelectronegativity\natomic radius\nion radius\nvan der Waals radius\n...\nEA\nstandard state\nbonding type\nmelting point\nboiling point\ndensity\nmetal\nyear discovered\ngroup\nperiod\n\n\n\n\n0\n1\nH\nHydrogen\n1.00794\n#FFFFFF\n1s1\n2.20\n37.0\nNaN\n120.0\n...\n-73.0\ngas\ndiatomic\n14.0\n20.0\n0.00009\nnonmetal\n1766\n1\n1\n\n\n1\n2\nHe\nHelium\n4.002602\n#D9FFFF\n1s2\nNaN\n32.0\nNaN\n140.0\n...\n0.0\ngas\natomic\nNaN\n4.0\n0.00000\nnoble gas\n1868\n18\n1\n\n\n2\n3\nLi\nLithium\n6.941\n#CC80FF\n[He] 2s1\n0.98\n134.0\n76 (+1)\n182.0\n...\n-60.0\nsolid\nmetallic\n454.0\n1615.0\n0.54000\nalkali metal\n1817\n1\n2\n\n\n3\n4\nBe\nBeryllium\n9.012182\n#C2FF00\n[He] 2s2\n1.57\n90.0\n45 (+2)\nNaN\n...\n0.0\nsolid\nmetallic\n1560.0\n2743.0\n1.85000\nalkaline earth metal\n1798\n2\n2\n\n\n4\n5\nB\nBoron\n10.811\n#FFB5B5\n[He] 2s2 2p1\n2.04\n82.0\n27 (+3)\nNaN\n...\n-27.0\nsolid\ncovalent network\n2348.0\n4273.0\n2.46000\nmetalloid\n1807\n13\n2\n\n\n\n\n5 rows × 21 columns\n\n\n\nAlter the data types of the information that will be plotted. This makes it convenient to work with.\n\nelements['group'] = [-1 if g == '-' else int(g) for g in elements.group]\nelements['bonding type'] = elements['bonding type'].astype('category')\nelements['metal'] = elements['metal'].astype('category')\nelements['atomic_number'] = elements['atomic number'].astype(str)\n\nThe periodic table has two tables, a top and bottom. The elements in the top have groups, and those in the bottom have no groups. We make separate dataframes for both – they have different alignments.\n\ntop = elements.query('group != -1').copy()\nbottom = elements.query('group == -1').copy()\n\nThe top table is nice and well behaving. The x location of the elements indicate the group and the y locations the period.\n\ntop['x'] = top.group\ntop['y'] = top.period\n\nThe bottom table has 2 rows, with the atomic number increasing to the right. We create an x based on the atomic number and add a horizontal shift. As the dataframe is ordered by atomic number, the operation is easier. The bottom elements are labelled with a “period”. We add a vertical shift to give us a good y location that gives the appearance of two tables.\n\nnrows = 2\nhshift = 3.5\nvshift = 3\nbottom['x'] = np.tile(np.arange(len(bottom)//nrows), nrows) + hshift\nbottom['y'] = bottom.period + vshift\n\nWe will be plotting using tiles and we want to have some space between the tiles. We have set the x and y locations above to take up a unit of space. To get a good effect, the tile dimensions should be less than 1.\n\ntile_width = 0.95\ntile_height = 0.95\n\nFirst peak\n\n(ggplot(aes('x', 'y'))\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThe table upside down. We could have been more careful when creating the y locations since the periods are drawn in descending order. But, we can fix that with a reverse scale.\n\n(ggplot(aes('x', 'y'))\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + scale_y_reverse() # new\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nLet us apply some color to it.\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')  # new\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + scale_y_reverse()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\n\nNow for some trick\nGoal: To add text to the tiles\nThere are four pieces of text that we shall add to the tiles, that is 4 geom_text additions. As we have two tables, that comes to 8 geom_text additions. When any geom is added to a ggplot object, behind the scenes a layer is created and added. We can create a group of layers that can be added to a ggplot object in one go using a list.\nWe use a function that accepts a dataframe, and returns a list of geoms.\n\ndef inner_text(data):\n    layers = [geom_text(data, aes(label='atomic_number'), nudge_x=-0.40, nudge_y=0.40,\n                        ha='left', va='top', fontweight='normal', size=6),\n              geom_text(data, aes(label='symbol'), nudge_y=.1, size=9),\n              geom_text(data, aes(label='name'), nudge_y=-0.125, fontweight='normal', size=4.5),\n              geom_text(data, aes(label='atomic mass'), nudge_y=-.3, fontweight='normal', size=4.5)]\n    return layers\n\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + inner_text(top)    # new\n + inner_text(bottom) # new\n + scale_y_reverse()\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nIt is crowded in there and the tiles do not have equal dimentions. Use the theme create a larger figure. coord_equal give us equal units along the axes, this makes the tiles square.\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + inner_text(top)\n + inner_text(bottom)\n + scale_y_reverse()\n + coord_equal(expand=False)   # new\n + theme(figure_size=(12, 6))  # new\n)\n\n\n\n\n&lt;Figure Size: (1200 x 600)&gt;\n\n\nIt is has all the information we want, except one for complication. Elements Lu and Lr also belong in the bottom table. One way to show this duality is to have tiles with two colors split horizontally.\nThe colors are determined by the metal field, and we know the x and y locations. We create a dataframe with this information to create a half-tile. A half-tile is centered at the quarter mark.\n\nsplit_df = pd.DataFrame({\n    'x': 3-tile_width/4,\n    'y': [6, 7],\n    'metal': pd.Categorical(['lanthanoid', 'actinoid'])\n})\n\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(split_df, aes(width=tile_width/2, height=tile_height))  # new\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + inner_text(top)\n + inner_text(bottom)\n + scale_y_reverse()\n + coord_equal(expand=False)\n + theme(figure_size=(12, 6))\n)\n\n\n\n\n&lt;Figure Size: (1200 x 600)&gt;\n\n\nChange the fill color for a different look and use a theme that clears out all the clutter.\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(split_df, aes(width=tile_width/2, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + inner_text(top)\n + inner_text(bottom)\n + scale_y_reverse()\n + scale_fill_brewer(type='qual', palette=3)         # new\n + coord_equal(expand=False)\n + theme_void()                                      # new\n + theme(figure_size=(12, 6),\n         plot_background=element_rect(fill='white')) # new\n        \n)\n\n\n\n\n&lt;Figure Size: (1200 x 600)&gt;\n\n\nAdd the group number along the top most row of each column, and period number along the left side of the top table.\nFor the period number, we set the breaks on the y scale.\n\n# The location of the group number is the top most (and therefore smallest period)\n# element with the group\ngroupdf = top.groupby(\n    'group'\n).agg(\n    y=('period', np.min)\n).reset_index()\n\nFinally,\n\n# Gallery Plot\n\n(ggplot(aes('x', 'y'))\n + aes(fill='metal')\n + geom_tile(top, aes(width=tile_width, height=tile_height))\n + geom_tile(split_df, aes(width=tile_width/2, height=tile_height))\n + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n + inner_text(top)\n + inner_text(bottom)\n + geom_text(groupdf, aes('group', 'y', label='group'), color='gray', nudge_y=.525,\n             va='bottom',fontweight='normal', size=9, inherit_aes=False)    # new\n + scale_y_reverse(breaks=range(1, 8), limits=(0, 10.5))                    # modified\n + scale_fill_brewer(type='qual', palette=3) \n + coord_equal(expand=False)\n + theme_void()\n + theme(figure_size=(12, 6),\n         plot_background=element_rect(fill='white'),\n         axis_text_y=element_text(margin={'r': 5}, color='gray', size=9)    # new\n         )\n)\n\n\n\n\n&lt;Figure Size: (1200 x 600)&gt;\n\n\nWhat we could have done different:\n\nAfter we set the x and y positions in th the top and bottom dataframes, we could have concatenated them back together. Then, that Layers trick would not save us much.\n\nPro tip: Save the plot as a pdf.\n\n\nAnnotated Heatmap\nConditinous data recorded at discrete time intervals over many cycles\nRead data\n\nflights = pd.read_csv('data/flights.csv')\nmonths = flights['month'].unique()  # Months ordered January, ..., December\nflights['month'] = pd.Categorical(flights['month'], categories=months)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\n\n# We use 'factor(year)' -- a discrete -- instead of 'year' so that all the years\n# are displayed along the x-axis.\n# The .95s create spacing between the tiles.\n\n(ggplot(flights, aes('factor(year)', 'month', fill='passengers'))\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers'), size=9)\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nThat looks like what we want, but it could do with a few tweaks. First the contrast between the tiles and the text is not good for the lower passenger numbers. We use pd.cut to partition the number of passengers into two discrete groups.\n\nflights['p_group'] = pd.cut(flights['passengers'], (0, 300, 1000), labels=(\"low\", 'high'))\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\np_group\n\n\n\n\n0\n1949\nJanuary\n112\nlow\n\n\n1\n1949\nFebruary\n118\nlow\n\n\n2\n1949\nMarch\n132\nlow\n\n\n3\n1949\nApril\n129\nlow\n\n\n4\n1949\nMay\n121\nlow\n\n\n\n\n\n\n\n\n(ggplot(flights, aes('factor(year)', 'month', fill='passengers'))\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)  # modified\n + scale_color_manual(['white', 'black']) # new\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nLast tweaks, put January at the top and remove the axis ticks and plot background.\n\n# Gallery Plot\n\n(ggplot(flights, aes('factor(year)', 'month', fill='passengers'))\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\n + scale_color_manual(['white', 'black']) # new\n + scale_y_discrete(limits=months[::-1])          # new\n + theme(                                         # new\n     axis_ticks=element_blank(),\n     panel_background=element_rect(fill='white')\n )\n)\n\n\n\n\n&lt;Figure Size: (640 x 480)&gt;\n\n\nYou can get similar results if you replace\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nwith\n+ geom_label(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nCredit: This example is a recreation of this seaborn example."
  }
]